<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>JavaScript笔记：迭代器和生成器 - Hooyu&#39;s Note</title>
<link rel="shortcut icon" href="https://blog.ikozn.com//favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://blog.ikozn.com//media/css/tailwind.css">
<link rel="stylesheet" href="https://blog.ikozn.com//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JavaScript笔记：迭代器和生成器 - Hooyu&#39;s Note - Atom Feed" href="https://blog.ikozn.com//atom.xml">

    

  <meta name="description" content="前言

给复习时的自己看，快速回顾

迭代器快速回顾


迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。


任何实现Iterable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器。

..." />
  <meta property="og:title" content="JavaScript笔记：迭代器和生成器 - Hooyu&#39;s Note">
  <meta property="og:description" content="前言

给复习时的自己看，快速回顾

迭代器快速回顾


迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。


任何实现Iterable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器。

..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://blog.ikozn.com/post/javascript-bi-ji-die-dai-qi-he-sheng-cheng-qi/" />
  <meta property="og:image" content="https://blog.ikozn.com//images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="JavaScript笔记：迭代器和生成器 - Hooyu&#39;s Note">
  <meta name="twitter:description" content="前言

给复习时的自己看，快速回顾

迭代器快速回顾


迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。


任何实现Iterable接口的对象都有一个Symbol.iterator属性，这个属性引用默认迭代器。

...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://blog.ikozn.com/post/javascript-bi-ji-die-dai-qi-he-sheng-cheng-qi/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://blog.ikozn.com//media/css/prism-vs-light.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://blog.ikozn.com/" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      Hooyu&#39;s Note
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          JavaScript笔记：迭代器和生成器
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2021-05-16 · 28 min read</div>
          
            <a href="https://blog.ikozn.com/tag/Uk35PYx0o/" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              javascript
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <h1 id="前言">前言</h1>
<blockquote>
<p>给复习时的自己看，快速回顾</p>
</blockquote>
<h2 id="迭代器快速回顾">迭代器快速回顾</h2>
<ol>
<li>
<p>迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。</p>
</li>
<li>
<p>任何实现<code>Iterable</code>接口的对象都有一个<code>Symbol.iterator</code>属性，这个属性引用默认迭代器。</p>
</li>
<li>
<p>默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现<code>Iterator</code>接口的对象</p>
<p>这个接口可以通过手动反复调用<code>next()</code>方法来消费，也可以通过原生消费者，比如<code>for-of</code>循环来自动消费。</p>
</li>
<li>
<p>迭代器必须通过连续调用<code>next()</code>方法才能连续取得值，这个方法返回一个<code>IteratorObject</code>。</p>
</li>
<li>
<p>这个对象包含一个<code>done</code>属性和一个<code>value</code>属性。</p>
<p>前者是一个布尔值，表示是否还有更多值可以访问，后者包含迭代器返回的当前值</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">概念</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">迭代器模式</td>
<td style="text-align:left">分离分离<code>Iterable</code>（可迭代对象）和<code>Iterator</code>（迭代器），的一种模式。<br />迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值（下一个值）</td>
</tr>
<tr>
<td style="text-align:center">迭代协议</td>
<td style="text-align:left">分为<strong>可迭代协议</strong>和<strong>迭代器协议</strong>，一种约定，任何对象只要遵循约定就可以实现</td>
</tr>
<tr>
<td style="text-align:center">可迭代对象</td>
<td style="text-align:left">有<code>[Symbol.iterator]()</code>方法的对象，当然这个方法要遵循约定</td>
</tr>
<tr>
<td style="text-align:center">Iterable 接口</td>
<td style="text-align:left">就是对象上的<code>[Symbol.iterator]()</code>方法</td>
</tr>
<tr>
<td style="text-align:center">Iterrator</td>
<td style="text-align:left">迭代器，由<code>[Symbol.iterator]()</code>方法生产出来的对象，有<code>next()</code>方法<br />调用这个方法返回一个对象，对象里有当前迭代器的状态和获取到的值</td>
</tr>
</tbody>
</table>
<p><strong>自定义迭代器：</strong></p>
<pre><code class="language-js">class Counter {
  constructor(limit) {
    this.limit = limit;
  }

  // -  Iterable 接口
  [Symbol.iterator]() {
    let count = 1,
        limit = this.limit;

    // - 返回 Iterator（迭代器）
    return {
      next() {
        if (count &lt;= limit) {
          // - 返回 IteratorResult 对象 
          return { done: false, value: count++ };
        } else {
          // - 返回 IteratorResult 对象 
          return { done: true, value: undefined };
        }
      },
      // - Iterator（迭代器） 返回 迭代器本身
      [Symbol.iterator]() {
          return this
      }
    };
  }
}

let counter = new Counter(3);

for (let i of counter) { console.log(i); }
// 1
// 2
// 3

for (let i of counter) { console.log(i); }
// 1
// 2
// 3

let iter1 = counter[Symbol.iterator]();
let iter2 = iter1[Symbol.iterator]();
console.log(iter1 === iter2);         // true
</code></pre>
<p><strong>接收可迭代对象的原生语言特性：</strong></p>
<ul>
<li><code>for-of</code>循环</li>
<li>数组解构</li>
<li>扩展操作符</li>
<li><code>Array.from()</code></li>
<li>创建集合</li>
<li>创建映射</li>
<li><code>Promise.all()</code>接收由期约组成的可迭代对象</li>
<li><code>Promise.race()</code>接收由期约组成的可迭代对象</li>
<li><code>yield*</code>操作符，在生成器中使用</li>
</ul>
<p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数（也就是<code>Symbol.iterator</code>），从而创建一个迭代器：</p>
<pre><code class="language-js">let arr = ['foo', 'bar', 'baz'];

// for-of循环
for (let el of arr) {
  console.log(el);
}
// foo
// bar
// baz

// 数组解构
let [a, b, c] = arr;
console.log(a, b, c); // foo, bar, baz

// 扩展操作符
let arr2 = [...arr];
console.log(arr2); // ['foo', 'bar', 'baz']

// Array.from()
let arr3 = Array.from(arr);
console.log(arr3); // ['foo', 'bar', 'baz']

// Set构造函数
let set = new Set(arr);
console.log(set); // Set(3) {'foo', 'bar', 'baz'}

// Map构造函数
let pairs = arr.map((x, i) =&gt; [x, i]);
console.log(pairs); // [['foo', 0], ['bar', 1], ['baz', 2]]
let map = new Map(pairs);
console.log(map); // Map(3) { 'foo'=&gt;0, 'bar'=&gt;1, 'baz'=&gt;2 }
</code></pre>
<h2 id="生成器快速回顾">生成器快速回顾</h2>
<ol>
<li>
<p>生成器是一种特殊的函数，调用之后会返回一个生成器对象。</p>
</li>
<li>
<p>生成器对象实现了<code>Iterable</code>接口，因此可用在任何消费可迭代对象的地方。</p>
</li>
<li>
<p>生成器的独特之处在于支持<code>yield</code>关键字，这个关键字能够暂停执行生成器函数</p>
</li>
<li>
<p>使用<code>yield</code>关键字还可以通过<code>next()</code>方法接收输入和产生输出。</p>
</li>
<li>
<p>在加上星号之后，<code>yield</code>关键字可以将跟在它后面的可迭代对象序列化为一连串值（让权执行另一个迭代器）。</p>
</li>
</ol>
<p><strong>表现形式：</strong></p>
<pre><code class="language-js">function* generatorFn() {
  yield 1;
  yield 2;
  yield 3;
}

for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<h1 id="迭代器">迭代器</h1>
<h2 id="what">What</h2>
<h3 id="迭代器模式和迭代协议是什么">迭代器模式和迭代协议是什么？</h3>
<ol>
<li>
<p>迭代器模式是什么？</p>
<p><strong>迭代器模式</strong>是GoF设计模式中的一种行为型模式，提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<p>在这里（ECMAScript）的具体表现为分离<code>Iterable</code>（可迭代对象）和<code>Iterator</code>（迭代器）</p>
<p>迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值（下一个值）</p>
</li>
<li>
<p>迭代协议是什么？</p>
<p>ECMAScript 2015 的一组补充规范，迭代协议并不是新的内置实现或语法，而是<em>协议</em>。这些协议可以被任何遵循某些约定的对象来实现。</p>
<p>迭代协议具体分为两个协议：[可迭代协议](#可迭代协议 与 Iterable 接口 是什么？)和[迭代器协议](#迭代器协议 与 Iterator  是什么？)。</p>
</li>
</ol>
<h3 id="可迭代对象iterable-是什么">可迭代对象/iterable 是什么？</h3>
<p>把满足<strong>特定条件</strong>的结构称为**“可迭代对象”（iterable）**，例如数组或集合这样的集合类型的对象，也可以是自定义的对象。</p>
<pre><code class="language-js">// 数组的元素是有限的
// 递增索引可以按序访问每个元素
let arr = [3, 1, 4];

// 集合的元素是有限的
// 可以按插入顺序访问每个元素
let set = new Set().add(3).add(1).add(4);
</code></pre>
<p>特定的条件有两个：</p>
<ol>
<li>实现了正式的[Iterable接口](#可迭代协议 与 Iterable 接口 是什么？)</li>
<li>实现的<code>Iterable</code>接口可以通过迭代器<code>Iterator</code>迭代</li>
</ol>
<h3 id="可迭代协议-与-iterable-接口-是什么">可迭代协议 与 Iterable 接口 是什么？</h3>
<ol>
<li>
<p>可迭代协议是什么？</p>
<p>可迭代协议并不是新的内置实现或语法，而是***协议***，这个协议可以被任何遵循某些约定的对象来实现，当某个对象实现了<code>Iterable</code>接口可以视为实现了可迭代协议。</p>
</li>
<li>
<p><code>Iterable</code>接口是什么？</p>
<p><code>Iterable</code>接口指的是对象上使用<code>Symbol.iterator</code>作为键的一个属性，这个属性是一个迭代器工厂函数，调用这个工厂函数必须返回一个新[迭代器](#迭代器协议 与 Iterator  是什么？)</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>[Symbol.iterator]</code></td>
<td style="text-align:left">一个无参数的函数，其返回值为一个符合[迭代器协议](#迭代器协议 与 Iterator  是什么？)的对象</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="迭代器协议-与-iterator迭代器-是什么">迭代器协议 与 Iterator（迭代器）  是什么？</h3>
<ol>
<li>
<p><strong>迭代器协议 是什么？</strong></p>
<p><strong>迭代器协议</strong>定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。</p>
<p><strong>实现了<code>Iterator</code>就相当于实现了迭代器协议。</strong></p>
</li>
<li>
<p><strong>Iterator（迭代器） 是什么？</strong></p>
<p>其实就是指一个对象，这个对象包含着<code>next()</code>和<code>return()</code>（可选）两个方法。<br>
调用<code>Iterable</code>（可迭代协议接口）返回<code>Iterator</code>（迭代器），这是一种一次性使用的对象，用于迭代，其上有两个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>next()</code></td>
<td style="text-align:left">每次成功调用都会返回一个<code>IteratorResult</code>对象，其中包含迭代器返回的下一个值</td>
</tr>
<tr>
<td style="text-align:left"><code>return()</code></td>
<td style="text-align:left">可选的方法，用于指定在迭代器提前关闭时执行的逻辑，在[下面](#提前终止迭代器与return() 分别是什么？)有详细笔记</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="iteratorresult对象-是什么"><code>IteratorResult</code>对象 是什么？</h3>
<p>包含以下两个属性的对象：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>done</code></td>
<td style="text-align:left">一个布尔值，表示是否还可以再次调用<code>next()</code>取得下一个值；</td>
</tr>
<tr>
<td style="text-align:left"><code>value</code></td>
<td style="text-align:left">包含可迭代对象的下一个值（<code>done</code>为<code>false</code>）<br />或者<code>undefined</code>（<code>done</code>为<code>true</code>）</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<pre><code class="language-js">// 可迭代对象
let arr = ['foo', 'bar'];

// 迭代器工厂函数
console.log(arr[Symbol.iterator]); // f values() { [native code] }

// 迭代器
let iter = arr[Symbol.iterator]();
console.log(iter); // ArrayIterator {}

// 执行迭代
console.log(iter.next()); // { done: false, value: 'foo' }
console.log(iter.next()); // { done: false, value: 'bar' }
console.log(iter.next()); // { done: true, value: undefined }
</code></pre>
<h3 id="提前终止迭代器与return-分别是什么">提前终止迭代器与return() 分别是什么？</h3>
<ol>
<li>
<p>提前终止迭代器是什么？</p>
<p>讲的是当迭代器还能继续迭代但是需要提前退出迭代的一种情况</p>
<p>执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器</p>
<p>可能的情况包括：</p>
<ul>
<li><code>for-of</code>循环通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>throw</code>提前退出</li>
<li>解构操作没有用到全部的值</li>
</ul>
</li>
<li>
<p><code>return()</code>是什么？</p>
<p><code>Iterator</code>（迭代器）上的一个可选方法，用于指定在迭代器提前关闭时执行的逻辑</p>
<p>内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用<code>return()</code>方法</p>
<p><code>return()</code>方法必须返回一个有效的<code>IteratorResult</code>对象，简单的情况下，可以只返回<code>{ done: true }</code></p>
</li>
</ol>
<p><strong>例子</strong></p>
<pre><code class="language-js">class Counter {
  constructor(limit) {
    this.limit = limit;
  }

  [Symbol.iterator]() {
    let count = 1,
      limit = this.limit;
    return {
      next() {
        if (count &lt;= limit) {
          return { done: false, value: count++ };
        } else {
          return { done: true };
        }
      },
      return() {
        console.log('Exiting early');
        return { done: true };
      }
    };
  }
}


let counter1 = new Counter(5);

for (let i of counter1) {
  if (i &gt; 2) {
    break;
  }
  console.log(i);
}
// 1
// 2
// Exiting early


let counter2 = new Counter(5);

try {
  for (let i of counter2) {
    if (i &gt; 2) {
      throw 'err';
    }
    console.log(i);
  }
} catch(e) {}
// 1
// 2
// Exiting early


let counter3 = new Counter(5);

let [a, b] = counter3;
// Exiting early
</code></pre>
<p><strong>补充</strong></p>
<ol>
<li>
<p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代</p>
</li>
<li>
<p>不是所有迭代器都是可关闭的，仅仅给一个不可关闭的迭代器增加<code>return()</code>方法<strong>并不能</strong>让它变成可关闭的</p>
<p>这是因为调用<code>return()</code>不会强制迭代器进入关闭状态，即便如此，<code>return()</code>方法还是会被调用</p>
</li>
</ol>
<p><strong>例子1：</strong></p>
<pre><code class="language-js">// - 继续执行未关闭的迭代器
let a = [1, 2, 3, 4, 5];
let iter = a[Symbol.iterator]();

for (let i of iter) {
  console.log(i);
  if (i &gt; 2) {
    break
  }
}
// 1
// 2
// 3

for (let i of iter) {
  console.log(i);
}
// 4
// 5
</code></pre>
<p><strong>例子2：</strong></p>
<pre><code class="language-js">// - 尝试关闭数组的迭代器，失败
let a = [1, 2, 3, 4, 5];
let iter = a[Symbol.iterator]();

iter.return = function() {
  console.log('Exiting early');
  return { done: true };
};

for (let i of iter) {
  console.log(i);
  if (i &gt; 2) {
    break
  }
}
// 1
// 2
// 3
// 提前退出

for (let i of iter) {
  console.log(i);
}
// 4
// 5
</code></pre>
<h3 id="其他">其他</h3>
<ol>
<li>
<p>每个迭代器都表示对可迭代对象的一次性有序遍历</p>
<p>不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象</p>
<pre><code class="language-js">let arr = ['foo', 'bar'];
let iter1 = arr[Symbol.iterator]();
let iter2 = arr[Symbol.iterator]();

console.log(iter1.next()); // { done: false, value: 'foo' }
console.log(iter2.next()); // { done: false, value: 'foo' }
console.log(iter2.next()); // { done: false, value: 'bar' }
console.log(iter1.next()); // { done: false, value: 'bar' }
</code></pre>
</li>
<li>
<p>如果对象原型链上的父类实现了Iterable接口，那这个对象也就实现了这个接口</p>
<pre><code class="language-js">class FooArray extends Array {}
let fooArr = new FooArray('foo', 'bar', 'baz');

for (let el of fooArr) {
  console.log(el);
}
// foo
// bar
// baz
</code></pre>
</li>
</ol>
<h2 id="how">How</h2>
<h3 id="自定义迭代器">自定义迭代器</h3>
<p><strong>要点：</strong></p>
<ol>
<li><code>[Symbol.iterator]</code>是一个工厂函数，要实现闭包</li>
<li><code>iterator</code>（迭代器）也要实现<code>Iterable</code>（<code>[Symbol.iterator]</code>）接口</li>
</ol>
<pre><code class="language-js">class Counter {
  constructor(limit) {
    this.limit = limit;
  }

  [Symbol.iterator]() {
    let count = 1,
        limit = this.limit;
      		
    return {
      next() {
        if (count &lt;= limit) {
          return { done: false, value: count++ };
        } else {
          return { done: true, value: undefined };
        }
      },
      [Symbol.iterator]() {
          return this
      }
    };
  }
}

let counter = new Counter(3);

for (let i of counter) { console.log(i); }
// 1
// 2
// 3

for (let i of counter) { console.log(i); }
// 1
// 2
// 3

let iter1 = counter[Symbol.iterator]();
let iter2 = iter1[Symbol.iterator]();
console.log(iter1 === iter2);         // true
</code></pre>
<h3 id="一些实现了iterable接口的内置类型">一些实现了<code>Iterable</code>接口的内置类型</h3>
<ul>
<li>字符串</li>
<li>数组</li>
<li>映射</li>
<li>集合</li>
<li>TypedArray</li>
<li><code>arguments</code>对象</li>
<li><code>NodeList</code>等DOM集合类型</li>
</ul>
<h3 id="迭代器的应用">迭代器的应用</h3>
<p>随机点名，随机迭代人员，迭代完则重置，继续迭代</p>
<h1 id="生成器">生成器</h1>
<h2 id="what-2">What</h2>
<h3 id="什么是生成器">什么是生成器？</h3>
<ol>
<li>
<p><strong>生成器能做什么？</strong></p>
<p>拥有在一个函数块内暂停和恢复代码执行的能力，使用生成器可以自定义迭代器和实现协程。</p>
</li>
<li>
<p><strong>怎么创建生成器？</strong></p>
<p>生成器的形式是一个函数，函数名称前面加一个星号（<code>*</code>）表示它是一个生成器，可以给生成器传参</p>
<p>只要是可以定义函数的地方，就可以定义生成器。</p>
<pre><code class="language-js">// 生成器函数声明
function* generatorFn() {}

// 生成器函数表达式
let generatorFn = function* () {}

// 作为对象字面量方法的生成器函数
let foo = {
  * generatorFn() {}
}

// 作为类实例方法的生成器函数
class Foo {
  * generatorFn() {}
}

// 作为类静态方法的生成器函数
class Bar {
  static * generatorFn() {}
}
</code></pre>
</li>
<li>
<p><strong>什么是生成器对象？</strong></p>
<p>调用生成器函数会产生一个<strong>生成器对象</strong>，生成器对象一开始处于**暂停执行（suspended）**的状态</p>
<p>生成器对象也实现了<code>Iterator</code>接口，因此具有<code>next()</code>方法，调用这个方法会让生成器开始或恢复执行。</p>
</li>
</ol>
<h3 id="yield关键字有什么用">yield关键字有什么用？</h3>
<p>yield是生成器中才能使用的一个关键字，有四个作用：</p>
<ol>
<li>暂停：<code>yield</code>关键字可以让生成器暂停执行</li>
<li>输出：通过<code>yield</code>返回数据（调用<code>next()</code>返回的数据）</li>
<li>输入：通过<code>yield</code>获取<code>next()</code>传入的数据</li>
<li>序列化：通过<code>yield*</code>将可迭代对象序列化为一连串值</li>
</ol>
<h4 id="暂停让生成器停止执行">暂停：让生成器停止执行</h4>
<blockquote>
<p>yield让生成器进入暂停状态，只能通过调用next()恢复执行</p>
</blockquote>
<p>通过<code>yield</code>关键字退出的生成器函数会处在<code>done: false</code>状态；</p>
<p>通过<code>return</code>关键字退出的生成器函数会处于<code>done: true</code>状态。</p>
<pre><code class="language-js">function* generatorFn() {
  yield;
}

let generatorObject = generatorFn();

console.log(generatorObject.next());  // { done: false, value: undefined }
console.log(generatorObject.next());  // { done: true, value: undefined }
</code></pre>
<h4 id="输出通过yield返回数据">输出：通过<code>yield</code>返回数据</h4>
<pre><code class="language-js">function* generatorFn() {
  yield 'foo';
  yield 'bar';
  return 'baz';
}

let generatorObject = generatorFn();

console.log(generatorObject.next());  // { done: false, value: 'foo' }
console.log(generatorObject.next());  // { done: false, value: 'bar' }
console.log(generatorObject.next());  // { done: true, value: 'baz' }
</code></pre>
<h4 id="输入作为函数的中间参数使用">输入：作为函数的中间参数使用</h4>
<p>上一次让生成器函数暂停的<code>yield</code>关键字会接收到传给<code>next()</code>方法的第一个值。这里有个地方不太好理解——第一次调用<code>next()</code>传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：</p>
<pre><code class="language-js">function* generatorFn(initial) {
  console.log(initial);
  console.log(yield);
  console.log(yield);
}

let generatorObject = generatorFn('foo');

generatorObject.next('bar');  // foo
generatorObject.next('baz');  // baz
generatorObject.next('qux');  // qu
</code></pre>
<h4 id="序列化通过yield将可迭代对象序列化为一连串值">序列化：通过<code>yield*</code>将可迭代对象序列化为一连串值</h4>
<pre><code class="language-js">// 等价的generatorFn：
// function* generatorFn() {
//   for (const x of [1, 2, 3]) {
//     yield x;
//   }
// }
function* generatorFn() {
  yield* [1, 2, 3];
}

let generatorObject = generatorFn();

for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<p>与生成器函数的星号类似，<code>yield</code>星号两侧的空格不影响其行为：</p>
<pre><code class="language-js">function* generatorFn() {
  yield* [1, 2];
  yield *[3, 4];
  yield * [5, 6];
}

for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
// 4
// 5
// 6
</code></pre>
<p>因为<code>yield*</code>实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把<code>yield</code>放到一个循环里没什么不同。下面两个生成器函数的行为是等价的：</p>
<pre><code class="language-js">function* generatorFnA() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

for (const x of generatorFnA()) {
  console.log(x);
}
// 1
// 2
// 3

function* generatorFnB() {
  yield* [1, 2, 3];
}

for (const x of generatorFnB()) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<p><code>yield*</code>的值是关联迭代器返回<code>done: true</code>时的<code>value</code>属性。对于普通迭代器来说，这个值是<code>undefined</code>：</p>
<pre><code class="language-js">function* generatorFn() {
  console.log('iter value:', yield* [1, 2, 3]);
}

for (const x of generatorFn()) {
  console.log('value:', x);
}
// value: 1
// value: 2
// value: 3
// iter value: undefined
</code></pre>
<p>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</p>
<pre><code class="language-js">function* innerGeneratorFn() {
  yield 'foo';
  return 'bar';
}
function* outerGeneratorFn(genObj) {
  console.log('iter value:', yield* innerGeneratorFn());
}

for (const x of outerGeneratorFn()) {
  console.log('value:', x);
}
// value: foo
// iter value: bar
</code></pre>
<h4 id="让权通过yield将执行权移交给另一个生成器">让权：通过<code>yield*</code>将执行权移交给另一个生成器</h4>
<pre><code class="language-js">function* anotherGenerator(i) {
  yield i + 1;
  yield i + 2;
  yield i + 3;
}

function* generator(i){
  yield i;
  yield* anotherGenerator(i);// 移交执行权
  yield i + 10;
}

var gen = generator(10);

console.log(gen.next().value); // 10
console.log(gen.next().value); // 11
console.log(gen.next().value); // 12
console.log(gen.next().value); // 13
console.log(gen.next().value); // 20
</code></pre>
<h4 id="补充">补充</h4>
<ol>
<li>
<p><strong><code>yield</code>关键字可以同时用于输入和输出，如下例所示：</strong></p>
<pre><code class="language-js">// example1
function* generatorFn() {
  return yield 'foo';
}

let generatorObject = generatorFn();

console.log(generatorObject.next());       // { done: false, value: 'foo' }
console.log(generatorObject.next('bar'));  // { done: true, value: 'bar' }

// example2
function *createIterator() {
    let first = yield 1;
    let second = yield first + 2; // 4 + 2
                                  // first =4 是next(4)将参数赋给上一条的
    yield second + 3;             // 5 + 3
}

let iterator = createIterator();

console.log(iterator.next());    // &quot;{ value: 1, done: false }&quot;
console.log(iterator.next(4));   // &quot;{ value: 6, done: false }&quot;
console.log(iterator.next(5));   // &quot;{ value: 8, done: false }&quot;
console.log(iterator.next());    // &quot;{ value: undefined, done: true }&quot;
</code></pre>
<p>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到<code>yield</code>关键字时暂停执行并计算出要产生的值：<code>&quot;foo&quot;</code>。下一次调用<code>next()</code>传入了<code>&quot;bar&quot;</code>，作为交给同一个<code>yield</code>的值。然后这个值被确定为本次生成器函数要返回的值。</p>
</li>
<li>
<p><strong>生成器函数内部的执行流程会针对每个生成器对象区分作用域</strong></p>
<pre><code class="language-js">function* generatorFn() {
  yield 'foo';
  yield 'bar';
  return 'baz';
}

let generatorObject1 = generatorFn();
let generatorObject2 = generatorFn();


console.log(generatorObject1.next()); // { done: false, value: 'foo' }
console.log(generatorObject2.next()); // { done: false, value: 'foo' }
console.log(generatorObject2.next()); // { done: false, value: 'bar' }
console.log(generatorObject1.next()); // { done: false, value: 'bar' }
</code></pre>
</li>
<li>
<p><strong><code>yield</code>关键字只能在生成器函数内部使用，用在其他地方会抛出错误</strong></p>
<p>类似函数的<code>return</code>关键字，<code>yield</code>关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误</p>
<pre><code class="language-js">// 有效
function* validGeneratorFn() {
  yield;
}

// 无效
function* invalidGeneratorFnA() {
  function a() {
    yield;
  }
}

// 无效
function* invalidGeneratorFnB() {
  const b = () =&gt; {
    yield;
  }
}

// 无效
function* invalidGeneratorFnC() {
  (() =&gt; {
    yield;
  })();
}
</code></pre>
</li>
<li>
<p>检查是否存在默认迭代器属性</p>
<pre><code class="language-js">let num = 1;
let obj = {};

// 这两种类型没有实现迭代器工厂函数
console.log(num[Symbol.iterator]); // undefined
console.log(obj[Symbol.iterator]); // undefined

let str = 'abc';
let arr = ['a', 'b', 'c'];
let map = new Map().set('a', 1).set('b', 2).set('c', 3);
let set = new Set().add('a').add('b').add('c');
let els = document.querySelectorAll('div');

// 这些类型都实现了迭代器工厂函数
console.log(str[Symbol.iterator]); // f values() { [native code] }
console.log(arr[Symbol.iterator]); // f values() { [native code] }
console.log(map[Symbol.iterator]); // f values() { [native code] }
console.log(set[Symbol.iterator]); // f values() { [native code] }
console.log(els[Symbol.iterator]); // f values() { [native code] }

// 调用这个工厂函数会生成一个迭代器
console.log(str[Symbol.iterator]()); // StringIterator {}
console.log(arr[Symbol.iterator]()); // ArrayIterator {}
console.log(map[Symbol.iterator]()); // MapIterator {}
console.log(set[Symbol.iterator]()); // SetIterator {}
console.log(els[Symbol.iterator]()); // ArrayIterator {}
</code></pre>
</li>
</ol>
<h3 id="提前终止生成器">提前终止生成器</h3>
<p>与迭代器类似，生成器也支持“可关闭”的概念。一个实现<code>Iterator</code>接口的对象一定有<code>next()</code>方法，还有一个可选的<code>return()</code>方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法：<code>throw()</code>。</p>
<pre><code class="language-js">function* generatorFn() {}

const g = generatorFn();

console.log(g);         // generatorFn {&lt;suspended&gt;}
console.log(g.next);    // f next() { [native code] }
console.log(g.return);  // f return() { [native code] }
console.log(g.throw);   // f throw() { [native code] }
</code></pre>
<p><code>return()</code>和<code>throw()</code>方法都可以用于强制生成器进入关闭状态。</p>
<ol>
<li>
<p><strong><code>return()</code></strong></p>
<p><code>return()</code>方法会强制生成器进入关闭状态。提供给<code>return()</code>方法的值，就是终止迭代器对象的值：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

const g = generatorFn();

console.log(g);            // generatorFn {&lt;suspended&gt;}
console.log(g.return(4));  // { done: true, value: 4 }
console.log(g);            // generatorFn {&lt;closed&gt;}
</code></pre>
<p><strong>与迭代器不同，所有生成器对象都有<code>return()</code>方法，只要通过它进入关闭状态，就无法恢复了</strong>。后续调用<code>next()</code>会显示<code>done: true</code>状态，而提供的任何返回值都不会被存储或传播：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

const g = generatorFn();

console.log(g.next());     // { done: false, value: 1 }
console.log(g.return(4));  // { done: true, value: 4 }
console.log(g.next());     // { done: true, value: undefined }
console.log(g.next());     // { done: true, value: undefined }
console.log(g.next());     // { done: true, value: undefined }
</code></pre>
<p><code>for-of</code>循环等内置语言结构会忽略状态为<code>done: true</code>的<code>IteratorObject</code>内部返回的值。</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

const g = generatorFn();

for (const x of g) {
  if (x &gt; 1) {
    g.return(4);
  }
  console.log(x);
}
// 1
// 2
</code></pre>
</li>
<li>
<p><strong><code>throw()</code></strong></p>
<p><code>throw()</code>方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

const g = generatorFn();

console.log(g);   // generatorFn {&lt;suspended&gt;}
try {
  g.throw('foo');
} catch (e) {
  console.log(e); // foo
}
console.log(g);   // generatorFn {&lt;closed&gt;}
</code></pre>
<p>不过，假如生成器函数<strong>内部</strong>处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的<code>yield</code>，因此在这个例子中会跳过一个值。比如：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    try {
      yield x;
    } catch(e) {}
  }
}

const g = generatorFn();

console.log(g.next()); // { done: false, value: 1}
g.throw('foo');
console.log(g.next()); // { done: false, value: 3}
</code></pre>
<p>在这个例子中，生成器在<code>try</code>/<code>catch</code>块中的<code>yield</code>关键字处暂停执行。在暂停期间，<code>throw()</code>方法向生成器对象内部注入了一个错误：字符串<code>&quot;foo&quot;</code>。这个错误会被<code>yield</code>关键字抛出。因为错误是在生成器的<code>try</code>/<code>catch</code>块中抛出的，所以仍然在生成器内部被捕获。可是，由于<code>yield</code>抛出了那个错误，生成器就不会再产出值<code>2</code>。此时，生成器函数继续执行，在下一次迭代再次遇到<code>yield</code>关键字时产出了值<code>3</code>。</p>
<blockquote>
<p><strong>注意</strong>　如果生成器对象还没有开始执行，那么调用<code>throw()</code>抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。</p>
</blockquote>
</li>
</ol>
<h2 id="how-2">How</h2>
<h3 id="实践">实践</h3>
<h4 id="生成器对象作为可迭代对象"><strong>生成器对象作为可迭代对象</strong></h4>
<p>在生成器对象上显式调用<code>next()</code>方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便：</p>
<pre><code class="language-js">function* generatorFn() {
  yield 1;
  yield 2;
  yield 3;
}

for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<h4 id="使用yield实现递归算法"><strong>使用<code>yield*</code>实现递归算法</strong></h4>
<p><code>yield*</code>最有用的地方是实现递归操作，此时生成器可以产生自身。看下面的例子：</p>
<pre><code class="language-js">function* nTimes(n) {
  if (n &gt; 0) {
    yield* nTimes(n - 1);
    yield n - 1;
  }
}

for (const x of nTimes(3)) {
  console.log(x);
}
// 0
// 1
// 2

</code></pre>
<h3 id="应用">应用</h3>
<h4 id="生成器作为默认迭代器">生成器作为默认迭代器</h4>
<p>因为生成器对象实现了<code>Iterable</code>接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：</p>
<pre><code class="language-js">class Foo {
  constructor() {
    this.values = [1, 2, 3];
  }
  * [Symbol.iterator]() {
    yield* this.values;
  }
}

const f = new Foo();
for (const x of f) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<p>这里，<code>for-of</code>循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。这个生成器对象是可迭代的，所以完全可以在迭代中使用。</p>
<h4 id="无穷计数生成器函数">无穷计数生成器函数</h4>
<pre><code class="language-js">function* generatorFn() {
  for (let i = 0;;++i) {
    yield i;
  }
}

let generatorObject = generatorFn();

console.log(generatorObject.next().value);  // 0
console.log(generatorObject.next().value);  // 1
console.log(generatorObject.next().value);  // 2
console.log(generatorObject.next().value);  // 3
console.log(generatorObject.next().value);  // 4
console.log(generatorObject.next().value);  // 5
</code></pre>
<h4 id="实现范围和填充数组">实现范围和填充数组</h4>
<pre><code class="language-js">function* range(start, end) {
  while(end &gt; start) {
    yield start++;
  }
}

for (const x of range(4, 7)) {
  console.log(x);
}
// 4
// 5
// 6

function* zeroes(n) {
  while(n--) {
    yield 0;
  }
}

console.log(Array.from(zeroes(8))); // [0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<h4 id="递归遍历图">递归遍历图</h4>
<p>在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。</p>
<p>使用递归生成器结构和<code>yield*</code>可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：</p>
<pre><code class="language-js">class Node {
  constructor(id) {
    this.id = id;
    this.neighbors = new Set();
  }

  connect(node) {
    if (node !== this) {
      this.neighbors.add(node);
      node.neighbors.add(this);
    }
  }
}

class RandomGraph {
  constructor(size) {
    this.nodes = new Set();

    // 创建节点
    for (let i = 0; i &lt; size; ++i) {
      this.nodes.add(new Node(i));
    }

    // 随机连接节点
    const threshold = 1 / size;
    for (const x of this.nodes) {
      for (const y of this.nodes) {
        if (Math.random() &lt; threshold) {
          x.connect(y);
        }
      }
    }
  }

  // 这个方法仅用于调试
  print() {
    for (const node of this.nodes) {
      const ids = [...node.neighbors]
                      .map((n) =&gt; n.id)
                      .join(',');

      console.log(`${node.id}: ${ids}`);
    }
  }
}

const g = new RandomGraph(6);

g.print();
// 示例输出：
// 0: 2,3,5
// 1: 2,3,4,5
// 2: 1,3
// 3: 0,1,2,4
// 4: 2,3
// 5: 0,4
</code></pre>
<p>图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：</p>
<pre><code class="language-js">class Node {
  constructor(id) {
    ...
  }

  connect(node) {
    ...
  }
}

class RandomGraph {
  constructor(size) {
    ...
  }

  print() {
    ...
  }

  isConnected() {
    const visitedNodes = new Set();

    function* traverse(nodes) {
      for (const node of nodes) {
        if (!visitedNodes.has(node)) {
          yield node;
          yield* traverse(node.neighbors);
        }
      }
    }

    // 取得集合中的第一个节点
    const firstNode = this.nodes[Symbol.iterator]().next().value;

    // 使用递归生成器迭代每个节点
    for (const node of traverse([firstNode])) {
      visitedNodes.add(node);
    }

    return visitedNodes.size === this.nodes.size;
  }
}
</code></pre>
<h4 id="使用迭代器遍历二维数组并转换成一维数组">使用迭代器遍历二维数组并转换成一维数组</h4>
<pre><code class="language-js">function* iterArr(arr) {            //迭代器返回一个迭代器对象
  if (Array.isArray(arr)) {         // 内节点
      for(let i=0; i &lt; arr.length; i++) {
          yield* iterArr(arr[i]);   // (*)递归
      }
  } else {                          // 离开
      yield arr;
  }
}
// 使用 for-of 遍历:
var arr = ['a', ['b', 'c'], ['d', 'e']];
for(var x of iterArr(arr)) {
        console.log(x);               // a  b  c  d  e
 }

// 或者直接将迭代器展开:
var arr = [ 'a', ['b',[ 'c', ['d', 'e']]]];
var gen = iterArr(arr);
arr = [...gen];                        // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
</code></pre>
<h1 id="学习资料">学习资料</h1>
<ul>
<li>《JavaScript高级程序设计（第4版）》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">迭代协议</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">Generator</a></li>
</ul>
<h1 id="待学习资料">待学习资料</h1>
<p>https://segmentfault.com/a/1190000010747122</p>
<p>https://2ality.com/2017/12/for-await-of-sync-iterables.html</p>
<p>[Thunk 函数](https://es6.ruanyifeng.com/?search=迭代&amp;x=0&amp;y=0#docs/generator-async#Thunk 函数)</p>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      
        
          <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script type="application/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script type="application/javascript">

  var gitalk = new Gitalk({
    clientID: '0db2ec692e695c68b01b',
    clientSecret: '3db8da412bbe1c349309420810429c6121a95249',
    repo: 'blog-comments',
    owner: 'ikozn',
    admin: ['ikozn'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

        

        
      

      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  怕什么真理无穷，进一寸有一寸的欢喜
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE">迭代器快速回顾</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE">生成器快速回顾</a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#what">What</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88">迭代器模式和迭代协议是什么？</a></li>
<li><a href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1iterable-%E6%98%AF%E4%BB%80%E4%B9%88">可迭代对象/iterable 是什么？</a></li>
<li><a href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE-%E4%B8%8E-iterable-%E6%8E%A5%E5%8F%A3-%E6%98%AF%E4%BB%80%E4%B9%88">可迭代协议 与 Iterable 接口 是什么？</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE-%E4%B8%8E-iterator%E8%BF%AD%E4%BB%A3%E5%99%A8-%E6%98%AF%E4%BB%80%E4%B9%88">迭代器协议 与 Iterator（迭代器）  是什么？</a></li>
<li><a href="#iteratorresult%E5%AF%B9%E8%B1%A1-%E6%98%AF%E4%BB%80%E4%B9%88"><code>IteratorResult</code>对象 是什么？</a></li>
<li><a href="#%E6%8F%90%E5%89%8D%E7%BB%88%E6%AD%A2%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8Ereturn-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">提前终止迭代器与return() 分别是什么？</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
<li><a href="#how">How</a>
<ul>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8">自定义迭代器</a></li>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%8E%B0%E4%BA%86iterable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">一些实现了<code>Iterable</code>接口的内置类型</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8">迭代器的应用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a>
<ul>
<li><a href="#what-2">What</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E5%99%A8">什么是生成器？</a></li>
<li><a href="#yield%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">yield关键字有什么用？</a>
<ul>
<li><a href="#%E6%9A%82%E5%81%9C%E8%AE%A9%E7%94%9F%E6%88%90%E5%99%A8%E5%81%9C%E6%AD%A2%E6%89%A7%E8%A1%8C">暂停：让生成器停止执行</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E9%80%9A%E8%BF%87yield%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE">输出：通过<code>yield</code>返回数据</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AD%E9%97%B4%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8">输入：作为函数的中间参数使用</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%9A%E8%BF%87yield%E5%B0%86%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BA%E4%B8%80%E8%BF%9E%E4%B8%B2%E5%80%BC">序列化：通过<code>yield*</code>将可迭代对象序列化为一连串值</a></li>
<li><a href="#%E8%AE%A9%E6%9D%83%E9%80%9A%E8%BF%87yield%E5%B0%86%E6%89%A7%E8%A1%8C%E6%9D%83%E7%A7%BB%E4%BA%A4%E7%BB%99%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90%E5%99%A8">让权：通过<code>yield*</code>将执行权移交给另一个生成器</a></li>
<li><a href="#%E8%A1%A5%E5%85%85">补充</a></li>
</ul>
</li>
<li><a href="#%E6%8F%90%E5%89%8D%E7%BB%88%E6%AD%A2%E7%94%9F%E6%88%90%E5%99%A8">提前终止生成器</a></li>
</ul>
</li>
<li><a href="#how-2">How</a>
<ul>
<li><a href="#%E5%AE%9E%E8%B7%B5">实践</a>
<ul>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><strong>生成器对象作为可迭代对象</strong></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8yield%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><strong>使用<code>yield*</code>实现递归算法</strong></a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8">应用</a>
<ul>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E8%BF%AD%E4%BB%A3%E5%99%A8">生成器作为默认迭代器</a></li>
<li><a href="#%E6%97%A0%E7%A9%B7%E8%AE%A1%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0">无穷计数生成器函数</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E8%8C%83%E5%9B%B4%E5%92%8C%E5%A1%AB%E5%85%85%E6%95%B0%E7%BB%84">实现范围和填充数组</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%9B%BE">递归遍历图</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%B9%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">使用迭代器遍历二维数组并转换成一维数组</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99">学习资料</a></li>
<li><a href="#%E5%BE%85%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99">待学习资料</a></li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://blog.ikozn.com//media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://blog.ikozn.com//media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
</body>

</html>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.ikozn.com/</id>
    <title>Hooyu&apos;s Note</title>
    <updated>2021-05-18T02:04:40.098Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.ikozn.com/"/>
    <link rel="self" href="https://blog.ikozn.com/atom.xml"/>
    <subtitle>🗻提灯照胆看江山</subtitle>
    <logo>https://blog.ikozn.com/images/avatar.png</logo>
    <icon>https://blog.ikozn.com/favicon.ico</icon>
    <rights>All rights reserved 2021, Hooyu&apos;s Note</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript笔记：迭代器和生成器]]></title>
        <id>https://blog.ikozn.com/post/javascript-bi-ji-die-dai-qi-he-sheng-cheng-qi/</id>
        <link href="https://blog.ikozn.com/post/javascript-bi-ji-die-dai-qi-he-sheng-cheng-qi/">
        </link>
        <updated>2021-05-16T15:25:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>给复习时的自己看，快速回顾</p>
</blockquote>
<h2 id="迭代器快速回顾">迭代器快速回顾</h2>
<ol>
<li>
<p>迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。</p>
</li>
<li>
<p>任何实现<code>Iterable</code>接口的对象都有一个<code>Symbol.iterator</code>属性，这个属性引用默认迭代器。</p>
</li>
<li>
<p>默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现<code>Iterator</code>接口的对象</p>
<p>这个接口可以通过手动反复调用<code>next()</code>方法来消费，也可以通过原生消费者，比如<code>for-of</code>循环来自动消费。</p>
</li>
<li>
<p>迭代器必须通过连续调用<code>next()</code>方法才能连续取得值，这个方法返回一个<code>IteratorObject</code>。</p>
</li>
<li>
<p>这个对象包含一个<code>done</code>属性和一个<code>value</code>属性。</p>
<p>前者是一个布尔值，表示是否还有更多值可以访问，后者包含迭代器返回的当前值</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">概念</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">迭代器模式</td>
<td style="text-align:left">分离分离<code>Iterable</code>（可迭代对象）和<code>Iterator</code>（迭代器），的一种模式。<br />迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值（下一个值）</td>
</tr>
<tr>
<td style="text-align:center">迭代协议</td>
<td style="text-align:left">分为<strong>可迭代协议</strong>和<strong>迭代器协议</strong>，一种约定，任何对象只要遵循约定就可以实现</td>
</tr>
<tr>
<td style="text-align:center">可迭代对象</td>
<td style="text-align:left">有<code>[Symbol.iterator]()</code>方法的对象，当然这个方法要遵循约定</td>
</tr>
<tr>
<td style="text-align:center">Iterable 接口</td>
<td style="text-align:left">就是对象上的<code>[Symbol.iterator]()</code>方法</td>
</tr>
<tr>
<td style="text-align:center">Iterrator</td>
<td style="text-align:left">迭代器，由<code>[Symbol.iterator]()</code>方法生产出来的对象，有<code>next()</code>方法<br />调用这个方法返回一个对象，对象里有当前迭代器的状态和获取到的值</td>
</tr>
</tbody>
</table>
<p><strong>自定义迭代器：</strong></p>
<pre><code class="language-js">class Counter {
  constructor(limit) {
    this.limit = limit;
  }

  // -  Iterable 接口
  [Symbol.iterator]() {
    let count = 1,
        limit = this.limit;

    // - 返回 Iterator（迭代器）
    return {
      next() {
        if (count &lt;= limit) {
          // - 返回 IteratorResult 对象 
          return { done: false, value: count++ };
        } else {
          // - 返回 IteratorResult 对象 
          return { done: true, value: undefined };
        }
      },
      // - Iterator（迭代器） 返回 迭代器本身
      [Symbol.iterator]() {
          return this
      }
    };
  }
}

let counter = new Counter(3);

for (let i of counter) { console.log(i); }
// 1
// 2
// 3

for (let i of counter) { console.log(i); }
// 1
// 2
// 3

let iter1 = counter[Symbol.iterator]();
let iter2 = iter1[Symbol.iterator]();
console.log(iter1 === iter2);         // true
</code></pre>
<p><strong>接收可迭代对象的原生语言特性：</strong></p>
<ul>
<li><code>for-of</code>循环</li>
<li>数组解构</li>
<li>扩展操作符</li>
<li><code>Array.from()</code></li>
<li>创建集合</li>
<li>创建映射</li>
<li><code>Promise.all()</code>接收由期约组成的可迭代对象</li>
<li><code>Promise.race()</code>接收由期约组成的可迭代对象</li>
<li><code>yield*</code>操作符，在生成器中使用</li>
</ul>
<p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数（也就是<code>Symbol.iterator</code>），从而创建一个迭代器：</p>
<pre><code class="language-js">let arr = ['foo', 'bar', 'baz'];

// for-of循环
for (let el of arr) {
  console.log(el);
}
// foo
// bar
// baz

// 数组解构
let [a, b, c] = arr;
console.log(a, b, c); // foo, bar, baz

// 扩展操作符
let arr2 = [...arr];
console.log(arr2); // ['foo', 'bar', 'baz']

// Array.from()
let arr3 = Array.from(arr);
console.log(arr3); // ['foo', 'bar', 'baz']

// Set构造函数
let set = new Set(arr);
console.log(set); // Set(3) {'foo', 'bar', 'baz'}

// Map构造函数
let pairs = arr.map((x, i) =&gt; [x, i]);
console.log(pairs); // [['foo', 0], ['bar', 1], ['baz', 2]]
let map = new Map(pairs);
console.log(map); // Map(3) { 'foo'=&gt;0, 'bar'=&gt;1, 'baz'=&gt;2 }
</code></pre>
<h2 id="生成器快速回顾">生成器快速回顾</h2>
<ol>
<li>
<p>生成器是一种特殊的函数，调用之后会返回一个生成器对象。</p>
</li>
<li>
<p>生成器对象实现了<code>Iterable</code>接口，因此可用在任何消费可迭代对象的地方。</p>
</li>
<li>
<p>生成器的独特之处在于支持<code>yield</code>关键字，这个关键字能够暂停执行生成器函数</p>
</li>
<li>
<p>使用<code>yield</code>关键字还可以通过<code>next()</code>方法接收输入和产生输出。</p>
</li>
<li>
<p>在加上星号之后，<code>yield</code>关键字可以将跟在它后面的可迭代对象序列化为一连串值（让权执行另一个迭代器）。</p>
</li>
</ol>
<p><strong>表现形式：</strong></p>
<pre><code class="language-js">function* generatorFn() {
  yield 1;
  yield 2;
  yield 3;
}

for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<h1 id="迭代器">迭代器</h1>
<h2 id="what">What</h2>
<h3 id="迭代器模式和迭代协议是什么">迭代器模式和迭代协议是什么？</h3>
<ol>
<li>
<p>迭代器模式是什么？</p>
<p><strong>迭代器模式</strong>是GoF设计模式中的一种行为型模式，提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p>
<p>在这里（ECMAScript）的具体表现为分离<code>Iterable</code>（可迭代对象）和<code>Iterator</code>（迭代器）</p>
<p>迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值（下一个值）</p>
</li>
<li>
<p>迭代协议是什么？</p>
<p>ECMAScript 2015 的一组补充规范，迭代协议并不是新的内置实现或语法，而是<em>协议</em>。这些协议可以被任何遵循某些约定的对象来实现。</p>
<p>迭代协议具体分为两个协议：[可迭代协议](#可迭代协议 与 Iterable 接口 是什么？)和[迭代器协议](#迭代器协议 与 Iterator  是什么？)。</p>
</li>
</ol>
<h3 id="可迭代对象iterable-是什么">可迭代对象/iterable 是什么？</h3>
<p>把满足<strong>特定条件</strong>的结构称为**“可迭代对象”（iterable）**，例如数组或集合这样的集合类型的对象，也可以是自定义的对象。</p>
<pre><code class="language-js">// 数组的元素是有限的
// 递增索引可以按序访问每个元素
let arr = [3, 1, 4];

// 集合的元素是有限的
// 可以按插入顺序访问每个元素
let set = new Set().add(3).add(1).add(4);
</code></pre>
<p>特定的条件有两个：</p>
<ol>
<li>实现了正式的[Iterable接口](#可迭代协议 与 Iterable 接口 是什么？)</li>
<li>实现的<code>Iterable</code>接口可以通过迭代器<code>Iterator</code>迭代</li>
</ol>
<h3 id="可迭代协议-与-iterable-接口-是什么">可迭代协议 与 Iterable 接口 是什么？</h3>
<ol>
<li>
<p>可迭代协议是什么？</p>
<p>可迭代协议并不是新的内置实现或语法，而是***协议***，这个协议可以被任何遵循某些约定的对象来实现，当某个对象实现了<code>Iterable</code>接口可以视为实现了可迭代协议。</p>
</li>
<li>
<p><code>Iterable</code>接口是什么？</p>
<p><code>Iterable</code>接口指的是对象上使用<code>Symbol.iterator</code>作为键的一个属性，这个属性是一个迭代器工厂函数，调用这个工厂函数必须返回一个新[迭代器](#迭代器协议 与 Iterator  是什么？)</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>[Symbol.iterator]</code></td>
<td style="text-align:left">一个无参数的函数，其返回值为一个符合[迭代器协议](#迭代器协议 与 Iterator  是什么？)的对象</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="迭代器协议-与-iterator迭代器-是什么">迭代器协议 与 Iterator（迭代器）  是什么？</h3>
<ol>
<li>
<p><strong>迭代器协议 是什么？</strong></p>
<p><strong>迭代器协议</strong>定义了产生一系列值（无论是有限个还是无限个）的标准方式。当值为有限个时，所有的值都被迭代完毕后，则会返回一个默认返回值。</p>
<p><strong>实现了<code>Iterator</code>就相当于实现了迭代器协议。</strong></p>
</li>
<li>
<p><strong>Iterator（迭代器） 是什么？</strong></p>
<p>其实就是指一个对象，这个对象包含着<code>next()</code>和<code>return()</code>（可选）两个方法。<br>
调用<code>Iterable</code>（可迭代协议接口）返回<code>Iterator</code>（迭代器），这是一种一次性使用的对象，用于迭代，其上有两个方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>next()</code></td>
<td style="text-align:left">每次成功调用都会返回一个<code>IteratorResult</code>对象，其中包含迭代器返回的下一个值</td>
</tr>
<tr>
<td style="text-align:left"><code>return()</code></td>
<td style="text-align:left">可选的方法，用于指定在迭代器提前关闭时执行的逻辑，在[下面](#提前终止迭代器与return() 分别是什么？)有详细笔记</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="iteratorresult对象-是什么"><code>IteratorResult</code>对象 是什么？</h3>
<p>包含以下两个属性的对象：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>done</code></td>
<td style="text-align:left">一个布尔值，表示是否还可以再次调用<code>next()</code>取得下一个值；</td>
</tr>
<tr>
<td style="text-align:left"><code>value</code></td>
<td style="text-align:left">包含可迭代对象的下一个值（<code>done</code>为<code>false</code>）<br />或者<code>undefined</code>（<code>done</code>为<code>true</code>）</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<pre><code class="language-js">// 可迭代对象
let arr = ['foo', 'bar'];

// 迭代器工厂函数
console.log(arr[Symbol.iterator]); // f values() { [native code] }

// 迭代器
let iter = arr[Symbol.iterator]();
console.log(iter); // ArrayIterator {}

// 执行迭代
console.log(iter.next()); // { done: false, value: 'foo' }
console.log(iter.next()); // { done: false, value: 'bar' }
console.log(iter.next()); // { done: true, value: undefined }
</code></pre>
<h3 id="提前终止迭代器与return-分别是什么">提前终止迭代器与return() 分别是什么？</h3>
<ol>
<li>
<p>提前终止迭代器是什么？</p>
<p>讲的是当迭代器还能继续迭代但是需要提前退出迭代的一种情况</p>
<p>执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器</p>
<p>可能的情况包括：</p>
<ul>
<li><code>for-of</code>循环通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>throw</code>提前退出</li>
<li>解构操作没有用到全部的值</li>
</ul>
</li>
<li>
<p><code>return()</code>是什么？</p>
<p><code>Iterator</code>（迭代器）上的一个可选方法，用于指定在迭代器提前关闭时执行的逻辑</p>
<p>内置语言结构在发现还有更多值可以迭代，但不会消费这些值时，会自动调用<code>return()</code>方法</p>
<p><code>return()</code>方法必须返回一个有效的<code>IteratorResult</code>对象，简单的情况下，可以只返回<code>{ done: true }</code></p>
</li>
</ol>
<p><strong>例子</strong></p>
<pre><code class="language-js">class Counter {
  constructor(limit) {
    this.limit = limit;
  }

  [Symbol.iterator]() {
    let count = 1,
      limit = this.limit;
    return {
      next() {
        if (count &lt;= limit) {
          return { done: false, value: count++ };
        } else {
          return { done: true };
        }
      },
      return() {
        console.log('Exiting early');
        return { done: true };
      }
    };
  }
}


let counter1 = new Counter(5);

for (let i of counter1) {
  if (i &gt; 2) {
    break;
  }
  console.log(i);
}
// 1
// 2
// Exiting early


let counter2 = new Counter(5);

try {
  for (let i of counter2) {
    if (i &gt; 2) {
      throw 'err';
    }
    console.log(i);
  }
} catch(e) {}
// 1
// 2
// Exiting early


let counter3 = new Counter(5);

let [a, b] = counter3;
// Exiting early
</code></pre>
<p><strong>补充</strong></p>
<ol>
<li>
<p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代</p>
</li>
<li>
<p>不是所有迭代器都是可关闭的，仅仅给一个不可关闭的迭代器增加<code>return()</code>方法<strong>并不能</strong>让它变成可关闭的</p>
<p>这是因为调用<code>return()</code>不会强制迭代器进入关闭状态，即便如此，<code>return()</code>方法还是会被调用</p>
</li>
</ol>
<p><strong>例子1：</strong></p>
<pre><code class="language-js">// - 继续执行未关闭的迭代器
let a = [1, 2, 3, 4, 5];
let iter = a[Symbol.iterator]();

for (let i of iter) {
  console.log(i);
  if (i &gt; 2) {
    break
  }
}
// 1
// 2
// 3

for (let i of iter) {
  console.log(i);
}
// 4
// 5
</code></pre>
<p><strong>例子2：</strong></p>
<pre><code class="language-js">// - 尝试关闭数组的迭代器，失败
let a = [1, 2, 3, 4, 5];
let iter = a[Symbol.iterator]();

iter.return = function() {
  console.log('Exiting early');
  return { done: true };
};

for (let i of iter) {
  console.log(i);
  if (i &gt; 2) {
    break
  }
}
// 1
// 2
// 3
// 提前退出

for (let i of iter) {
  console.log(i);
}
// 4
// 5
</code></pre>
<h3 id="其他">其他</h3>
<ol>
<li>
<p>每个迭代器都表示对可迭代对象的一次性有序遍历</p>
<p>不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象</p>
<pre><code class="language-js">let arr = ['foo', 'bar'];
let iter1 = arr[Symbol.iterator]();
let iter2 = arr[Symbol.iterator]();

console.log(iter1.next()); // { done: false, value: 'foo' }
console.log(iter2.next()); // { done: false, value: 'foo' }
console.log(iter2.next()); // { done: false, value: 'bar' }
console.log(iter1.next()); // { done: false, value: 'bar' }
</code></pre>
</li>
<li>
<p>如果对象原型链上的父类实现了Iterable接口，那这个对象也就实现了这个接口</p>
<pre><code class="language-js">class FooArray extends Array {}
let fooArr = new FooArray('foo', 'bar', 'baz');

for (let el of fooArr) {
  console.log(el);
}
// foo
// bar
// baz
</code></pre>
</li>
</ol>
<h2 id="how">How</h2>
<h3 id="自定义迭代器">自定义迭代器</h3>
<p><strong>要点：</strong></p>
<ol>
<li><code>[Symbol.iterator]</code>是一个工厂函数，要实现闭包</li>
<li><code>iterator</code>（迭代器）也要实现<code>Iterable</code>（<code>[Symbol.iterator]</code>）接口</li>
</ol>
<pre><code class="language-js">class Counter {
  constructor(limit) {
    this.limit = limit;
  }

  [Symbol.iterator]() {
    let count = 1,
        limit = this.limit;
      		
    return {
      next() {
        if (count &lt;= limit) {
          return { done: false, value: count++ };
        } else {
          return { done: true, value: undefined };
        }
      },
      [Symbol.iterator]() {
          return this
      }
    };
  }
}

let counter = new Counter(3);

for (let i of counter) { console.log(i); }
// 1
// 2
// 3

for (let i of counter) { console.log(i); }
// 1
// 2
// 3

let iter1 = counter[Symbol.iterator]();
let iter2 = iter1[Symbol.iterator]();
console.log(iter1 === iter2);         // true
</code></pre>
<h3 id="一些实现了iterable接口的内置类型">一些实现了<code>Iterable</code>接口的内置类型</h3>
<ul>
<li>字符串</li>
<li>数组</li>
<li>映射</li>
<li>集合</li>
<li>TypedArray</li>
<li><code>arguments</code>对象</li>
<li><code>NodeList</code>等DOM集合类型</li>
</ul>
<h3 id="迭代器的应用">迭代器的应用</h3>
<p>随机点名，随机迭代人员，迭代完则重置，继续迭代</p>
<h1 id="生成器">生成器</h1>
<h2 id="what-2">What</h2>
<h3 id="什么是生成器">什么是生成器？</h3>
<ol>
<li>
<p><strong>生成器能做什么？</strong></p>
<p>拥有在一个函数块内暂停和恢复代码执行的能力，使用生成器可以自定义迭代器和实现协程。</p>
</li>
<li>
<p><strong>怎么创建生成器？</strong></p>
<p>生成器的形式是一个函数，函数名称前面加一个星号（<code>*</code>）表示它是一个生成器，可以给生成器传参</p>
<p>只要是可以定义函数的地方，就可以定义生成器。</p>
<pre><code class="language-js">// 生成器函数声明
function* generatorFn() {}

// 生成器函数表达式
let generatorFn = function* () {}

// 作为对象字面量方法的生成器函数
let foo = {
  * generatorFn() {}
}

// 作为类实例方法的生成器函数
class Foo {
  * generatorFn() {}
}

// 作为类静态方法的生成器函数
class Bar {
  static * generatorFn() {}
}
</code></pre>
</li>
<li>
<p><strong>什么是生成器对象？</strong></p>
<p>调用生成器函数会产生一个<strong>生成器对象</strong>，生成器对象一开始处于**暂停执行（suspended）**的状态</p>
<p>生成器对象也实现了<code>Iterator</code>接口，因此具有<code>next()</code>方法，调用这个方法会让生成器开始或恢复执行。</p>
</li>
</ol>
<h3 id="yield关键字有什么用">yield关键字有什么用？</h3>
<p>yield是生成器中才能使用的一个关键字，有四个作用：</p>
<ol>
<li>暂停：<code>yield</code>关键字可以让生成器暂停执行</li>
<li>输出：通过<code>yield</code>返回数据（调用<code>next()</code>返回的数据）</li>
<li>输入：通过<code>yield</code>获取<code>next()</code>传入的数据</li>
<li>序列化：通过<code>yield*</code>将可迭代对象序列化为一连串值</li>
</ol>
<h4 id="暂停让生成器停止执行">暂停：让生成器停止执行</h4>
<blockquote>
<p>yield让生成器进入暂停状态，只能通过调用next()恢复执行</p>
</blockquote>
<p>通过<code>yield</code>关键字退出的生成器函数会处在<code>done: false</code>状态；</p>
<p>通过<code>return</code>关键字退出的生成器函数会处于<code>done: true</code>状态。</p>
<pre><code class="language-js">function* generatorFn() {
  yield;
}

let generatorObject = generatorFn();

console.log(generatorObject.next());  // { done: false, value: undefined }
console.log(generatorObject.next());  // { done: true, value: undefined }
</code></pre>
<h4 id="输出通过yield返回数据">输出：通过<code>yield</code>返回数据</h4>
<pre><code class="language-js">function* generatorFn() {
  yield 'foo';
  yield 'bar';
  return 'baz';
}

let generatorObject = generatorFn();

console.log(generatorObject.next());  // { done: false, value: 'foo' }
console.log(generatorObject.next());  // { done: false, value: 'bar' }
console.log(generatorObject.next());  // { done: true, value: 'baz' }
</code></pre>
<h4 id="输入作为函数的中间参数使用">输入：作为函数的中间参数使用</h4>
<p>上一次让生成器函数暂停的<code>yield</code>关键字会接收到传给<code>next()</code>方法的第一个值。这里有个地方不太好理解——第一次调用<code>next()</code>传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：</p>
<pre><code class="language-js">function* generatorFn(initial) {
  console.log(initial);
  console.log(yield);
  console.log(yield);
}

let generatorObject = generatorFn('foo');

generatorObject.next('bar');  // foo
generatorObject.next('baz');  // baz
generatorObject.next('qux');  // qu
</code></pre>
<h4 id="序列化通过yield将可迭代对象序列化为一连串值">序列化：通过<code>yield*</code>将可迭代对象序列化为一连串值</h4>
<pre><code class="language-js">// 等价的generatorFn：
// function* generatorFn() {
//   for (const x of [1, 2, 3]) {
//     yield x;
//   }
// }
function* generatorFn() {
  yield* [1, 2, 3];
}

let generatorObject = generatorFn();

for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<p>与生成器函数的星号类似，<code>yield</code>星号两侧的空格不影响其行为：</p>
<pre><code class="language-js">function* generatorFn() {
  yield* [1, 2];
  yield *[3, 4];
  yield * [5, 6];
}

for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
// 4
// 5
// 6
</code></pre>
<p>因为<code>yield*</code>实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把<code>yield</code>放到一个循环里没什么不同。下面两个生成器函数的行为是等价的：</p>
<pre><code class="language-js">function* generatorFnA() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

for (const x of generatorFnA()) {
  console.log(x);
}
// 1
// 2
// 3

function* generatorFnB() {
  yield* [1, 2, 3];
}

for (const x of generatorFnB()) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<p><code>yield*</code>的值是关联迭代器返回<code>done: true</code>时的<code>value</code>属性。对于普通迭代器来说，这个值是<code>undefined</code>：</p>
<pre><code class="language-js">function* generatorFn() {
  console.log('iter value:', yield* [1, 2, 3]);
}

for (const x of generatorFn()) {
  console.log('value:', x);
}
// value: 1
// value: 2
// value: 3
// iter value: undefined
</code></pre>
<p>对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值：</p>
<pre><code class="language-js">function* innerGeneratorFn() {
  yield 'foo';
  return 'bar';
}
function* outerGeneratorFn(genObj) {
  console.log('iter value:', yield* innerGeneratorFn());
}

for (const x of outerGeneratorFn()) {
  console.log('value:', x);
}
// value: foo
// iter value: bar
</code></pre>
<h4 id="让权通过yield将执行权移交给另一个生成器">让权：通过<code>yield*</code>将执行权移交给另一个生成器</h4>
<pre><code class="language-js">function* anotherGenerator(i) {
  yield i + 1;
  yield i + 2;
  yield i + 3;
}

function* generator(i){
  yield i;
  yield* anotherGenerator(i);// 移交执行权
  yield i + 10;
}

var gen = generator(10);

console.log(gen.next().value); // 10
console.log(gen.next().value); // 11
console.log(gen.next().value); // 12
console.log(gen.next().value); // 13
console.log(gen.next().value); // 20
</code></pre>
<h4 id="补充">补充</h4>
<ol>
<li>
<p><strong><code>yield</code>关键字可以同时用于输入和输出，如下例所示：</strong></p>
<pre><code class="language-js">// example1
function* generatorFn() {
  return yield 'foo';
}

let generatorObject = generatorFn();

console.log(generatorObject.next());       // { done: false, value: 'foo' }
console.log(generatorObject.next('bar'));  // { done: true, value: 'bar' }

// example2
function *createIterator() {
    let first = yield 1;
    let second = yield first + 2; // 4 + 2
                                  // first =4 是next(4)将参数赋给上一条的
    yield second + 3;             // 5 + 3
}

let iterator = createIterator();

console.log(iterator.next());    // &quot;{ value: 1, done: false }&quot;
console.log(iterator.next(4));   // &quot;{ value: 6, done: false }&quot;
console.log(iterator.next(5));   // &quot;{ value: 8, done: false }&quot;
console.log(iterator.next());    // &quot;{ value: undefined, done: true }&quot;
</code></pre>
<p>因为函数必须对整个表达式求值才能确定要返回的值，所以它在遇到<code>yield</code>关键字时暂停执行并计算出要产生的值：<code>&quot;foo&quot;</code>。下一次调用<code>next()</code>传入了<code>&quot;bar&quot;</code>，作为交给同一个<code>yield</code>的值。然后这个值被确定为本次生成器函数要返回的值。</p>
</li>
<li>
<p><strong>生成器函数内部的执行流程会针对每个生成器对象区分作用域</strong></p>
<pre><code class="language-js">function* generatorFn() {
  yield 'foo';
  yield 'bar';
  return 'baz';
}

let generatorObject1 = generatorFn();
let generatorObject2 = generatorFn();


console.log(generatorObject1.next()); // { done: false, value: 'foo' }
console.log(generatorObject2.next()); // { done: false, value: 'foo' }
console.log(generatorObject2.next()); // { done: false, value: 'bar' }
console.log(generatorObject1.next()); // { done: false, value: 'bar' }
</code></pre>
</li>
<li>
<p><strong><code>yield</code>关键字只能在生成器函数内部使用，用在其他地方会抛出错误</strong></p>
<p>类似函数的<code>return</code>关键字，<code>yield</code>关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误</p>
<pre><code class="language-js">// 有效
function* validGeneratorFn() {
  yield;
}

// 无效
function* invalidGeneratorFnA() {
  function a() {
    yield;
  }
}

// 无效
function* invalidGeneratorFnB() {
  const b = () =&gt; {
    yield;
  }
}

// 无效
function* invalidGeneratorFnC() {
  (() =&gt; {
    yield;
  })();
}
</code></pre>
</li>
<li>
<p>检查是否存在默认迭代器属性</p>
<pre><code class="language-js">let num = 1;
let obj = {};

// 这两种类型没有实现迭代器工厂函数
console.log(num[Symbol.iterator]); // undefined
console.log(obj[Symbol.iterator]); // undefined

let str = 'abc';
let arr = ['a', 'b', 'c'];
let map = new Map().set('a', 1).set('b', 2).set('c', 3);
let set = new Set().add('a').add('b').add('c');
let els = document.querySelectorAll('div');

// 这些类型都实现了迭代器工厂函数
console.log(str[Symbol.iterator]); // f values() { [native code] }
console.log(arr[Symbol.iterator]); // f values() { [native code] }
console.log(map[Symbol.iterator]); // f values() { [native code] }
console.log(set[Symbol.iterator]); // f values() { [native code] }
console.log(els[Symbol.iterator]); // f values() { [native code] }

// 调用这个工厂函数会生成一个迭代器
console.log(str[Symbol.iterator]()); // StringIterator {}
console.log(arr[Symbol.iterator]()); // ArrayIterator {}
console.log(map[Symbol.iterator]()); // MapIterator {}
console.log(set[Symbol.iterator]()); // SetIterator {}
console.log(els[Symbol.iterator]()); // ArrayIterator {}
</code></pre>
</li>
</ol>
<h3 id="提前终止生成器">提前终止生成器</h3>
<p>与迭代器类似，生成器也支持“可关闭”的概念。一个实现<code>Iterator</code>接口的对象一定有<code>next()</code>方法，还有一个可选的<code>return()</code>方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法：<code>throw()</code>。</p>
<pre><code class="language-js">function* generatorFn() {}

const g = generatorFn();

console.log(g);         // generatorFn {&lt;suspended&gt;}
console.log(g.next);    // f next() { [native code] }
console.log(g.return);  // f return() { [native code] }
console.log(g.throw);   // f throw() { [native code] }
</code></pre>
<p><code>return()</code>和<code>throw()</code>方法都可以用于强制生成器进入关闭状态。</p>
<ol>
<li>
<p><strong><code>return()</code></strong></p>
<p><code>return()</code>方法会强制生成器进入关闭状态。提供给<code>return()</code>方法的值，就是终止迭代器对象的值：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

const g = generatorFn();

console.log(g);            // generatorFn {&lt;suspended&gt;}
console.log(g.return(4));  // { done: true, value: 4 }
console.log(g);            // generatorFn {&lt;closed&gt;}
</code></pre>
<p><strong>与迭代器不同，所有生成器对象都有<code>return()</code>方法，只要通过它进入关闭状态，就无法恢复了</strong>。后续调用<code>next()</code>会显示<code>done: true</code>状态，而提供的任何返回值都不会被存储或传播：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

const g = generatorFn();

console.log(g.next());     // { done: false, value: 1 }
console.log(g.return(4));  // { done: true, value: 4 }
console.log(g.next());     // { done: true, value: undefined }
console.log(g.next());     // { done: true, value: undefined }
console.log(g.next());     // { done: true, value: undefined }
</code></pre>
<p><code>for-of</code>循环等内置语言结构会忽略状态为<code>done: true</code>的<code>IteratorObject</code>内部返回的值。</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

const g = generatorFn();

for (const x of g) {
  if (x &gt; 1) {
    g.return(4);
  }
  console.log(x);
}
// 1
// 2
</code></pre>
</li>
<li>
<p><strong><code>throw()</code></strong></p>
<p><code>throw()</code>方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    yield x;
  }
}

const g = generatorFn();

console.log(g);   // generatorFn {&lt;suspended&gt;}
try {
  g.throw('foo');
} catch (e) {
  console.log(e); // foo
}
console.log(g);   // generatorFn {&lt;closed&gt;}
</code></pre>
<p>不过，假如生成器函数<strong>内部</strong>处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的<code>yield</code>，因此在这个例子中会跳过一个值。比如：</p>
<pre><code class="language-js">function* generatorFn() {
  for (const x of [1, 2, 3]) {
    try {
      yield x;
    } catch(e) {}
  }
}

const g = generatorFn();

console.log(g.next()); // { done: false, value: 1}
g.throw('foo');
console.log(g.next()); // { done: false, value: 3}
</code></pre>
<p>在这个例子中，生成器在<code>try</code>/<code>catch</code>块中的<code>yield</code>关键字处暂停执行。在暂停期间，<code>throw()</code>方法向生成器对象内部注入了一个错误：字符串<code>&quot;foo&quot;</code>。这个错误会被<code>yield</code>关键字抛出。因为错误是在生成器的<code>try</code>/<code>catch</code>块中抛出的，所以仍然在生成器内部被捕获。可是，由于<code>yield</code>抛出了那个错误，生成器就不会再产出值<code>2</code>。此时，生成器函数继续执行，在下一次迭代再次遇到<code>yield</code>关键字时产出了值<code>3</code>。</p>
<blockquote>
<p><strong>注意</strong>　如果生成器对象还没有开始执行，那么调用<code>throw()</code>抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。</p>
</blockquote>
</li>
</ol>
<h2 id="how-2">How</h2>
<h3 id="实践">实践</h3>
<h4 id="生成器对象作为可迭代对象"><strong>生成器对象作为可迭代对象</strong></h4>
<p>在生成器对象上显式调用<code>next()</code>方法的用处并不大。其实，如果把生成器对象当成可迭代对象，那么使用起来会更方便：</p>
<pre><code class="language-js">function* generatorFn() {
  yield 1;
  yield 2;
  yield 3;
}

for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<h4 id="使用yield实现递归算法"><strong>使用<code>yield*</code>实现递归算法</strong></h4>
<p><code>yield*</code>最有用的地方是实现递归操作，此时生成器可以产生自身。看下面的例子：</p>
<pre><code class="language-js">function* nTimes(n) {
  if (n &gt; 0) {
    yield* nTimes(n - 1);
    yield n - 1;
  }
}

for (const x of nTimes(3)) {
  console.log(x);
}
// 0
// 1
// 2

</code></pre>
<h3 id="应用">应用</h3>
<h4 id="生成器作为默认迭代器">生成器作为默认迭代器</h4>
<p>因为生成器对象实现了<code>Iterable</code>接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。下面是一个简单的例子，这个类的默认迭代器可以用一行代码产出类的内容：</p>
<pre><code class="language-js">class Foo {
  constructor() {
    this.values = [1, 2, 3];
  }
  * [Symbol.iterator]() {
    yield* this.values;
  }
}

const f = new Foo();
for (const x of f) {
  console.log(x);
}
// 1
// 2
// 3
</code></pre>
<p>这里，<code>for-of</code>循环调用了默认迭代器（它恰好又是一个生成器函数）并产生了一个生成器对象。这个生成器对象是可迭代的，所以完全可以在迭代中使用。</p>
<h4 id="无穷计数生成器函数">无穷计数生成器函数</h4>
<pre><code class="language-js">function* generatorFn() {
  for (let i = 0;;++i) {
    yield i;
  }
}

let generatorObject = generatorFn();

console.log(generatorObject.next().value);  // 0
console.log(generatorObject.next().value);  // 1
console.log(generatorObject.next().value);  // 2
console.log(generatorObject.next().value);  // 3
console.log(generatorObject.next().value);  // 4
console.log(generatorObject.next().value);  // 5
</code></pre>
<h4 id="实现范围和填充数组">实现范围和填充数组</h4>
<pre><code class="language-js">function* range(start, end) {
  while(end &gt; start) {
    yield start++;
  }
}

for (const x of range(4, 7)) {
  console.log(x);
}
// 4
// 5
// 6

function* zeroes(n) {
  while(n--) {
    yield 0;
  }
}

console.log(Array.from(zeroes(8))); // [0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
<h4 id="递归遍历图">递归遍历图</h4>
<p>在这个例子中，每个生成器首先都会从新创建的生成器对象产出每个值，然后再产出一个整数。结果就是生成器函数会递归地减少计数器值，并实例化另一个生成器对象。从最顶层来看，这就相当于创建一个可迭代对象并返回递增的整数。</p>
<p>使用递归生成器结构和<code>yield*</code>可以优雅地表达递归算法。下面是一个图的实现，用于生成一个随机的双向图：</p>
<pre><code class="language-js">class Node {
  constructor(id) {
    this.id = id;
    this.neighbors = new Set();
  }

  connect(node) {
    if (node !== this) {
      this.neighbors.add(node);
      node.neighbors.add(this);
    }
  }
}

class RandomGraph {
  constructor(size) {
    this.nodes = new Set();

    // 创建节点
    for (let i = 0; i &lt; size; ++i) {
      this.nodes.add(new Node(i));
    }

    // 随机连接节点
    const threshold = 1 / size;
    for (const x of this.nodes) {
      for (const y of this.nodes) {
        if (Math.random() &lt; threshold) {
          x.connect(y);
        }
      }
    }
  }

  // 这个方法仅用于调试
  print() {
    for (const node of this.nodes) {
      const ids = [...node.neighbors]
                      .map((n) =&gt; n.id)
                      .join(',');

      console.log(`${node.id}: ${ids}`);
    }
  }
}

const g = new RandomGraph(6);

g.print();
// 示例输出：
// 0: 2,3,5
// 1: 2,3,4,5
// 2: 1,3
// 3: 0,1,2,4
// 4: 2,3
// 5: 0,4
</code></pre>
<p>图数据结构非常适合递归遍历，而递归生成器恰好非常合用。为此，生成器函数必须接收一个可迭代对象，产出该对象中的每一个值，并且对每个值进行递归。这个实现可以用来测试某个图是否连通，即是否没有不可到达的节点。只要从一个节点开始，然后尽力访问每个节点就可以了。结果就得到了一个非常简洁的深度优先遍历：</p>
<pre><code class="language-js">class Node {
  constructor(id) {
    ...
  }

  connect(node) {
    ...
  }
}

class RandomGraph {
  constructor(size) {
    ...
  }

  print() {
    ...
  }

  isConnected() {
    const visitedNodes = new Set();

    function* traverse(nodes) {
      for (const node of nodes) {
        if (!visitedNodes.has(node)) {
          yield node;
          yield* traverse(node.neighbors);
        }
      }
    }

    // 取得集合中的第一个节点
    const firstNode = this.nodes[Symbol.iterator]().next().value;

    // 使用递归生成器迭代每个节点
    for (const node of traverse([firstNode])) {
      visitedNodes.add(node);
    }

    return visitedNodes.size === this.nodes.size;
  }
}
</code></pre>
<h4 id="使用迭代器遍历二维数组并转换成一维数组">使用迭代器遍历二维数组并转换成一维数组</h4>
<pre><code class="language-js">function* iterArr(arr) {            //迭代器返回一个迭代器对象
  if (Array.isArray(arr)) {         // 内节点
      for(let i=0; i &lt; arr.length; i++) {
          yield* iterArr(arr[i]);   // (*)递归
      }
  } else {                          // 离开
      yield arr;
  }
}
// 使用 for-of 遍历:
var arr = ['a', ['b', 'c'], ['d', 'e']];
for(var x of iterArr(arr)) {
        console.log(x);               // a  b  c  d  e
 }

// 或者直接将迭代器展开:
var arr = [ 'a', ['b',[ 'c', ['d', 'e']]]];
var gen = iterArr(arr);
arr = [...gen];                        // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
</code></pre>
<h1 id="学习资料">学习资料</h1>
<ul>
<li>《JavaScript高级程序设计（第4版）》</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">迭代协议</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator">Generator</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[本博客搜索反代上线]]></title>
        <id>https://blog.ikozn.com/post/本博客搜索反代上线/</id>
        <link href="https://blog.ikozn.com/post/本博客搜索反代上线/">
        </link>
        <updated>2018-03-27T16:40:55.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2018/03/28/5aba743212c12.jpg" alt="Google" loading="lazy"></figure>
<blockquote>
<p>账号与密码都是上图中第一个字母小写,点<a href="https://g.ikozn.com">这里</a>访问</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[DCN]浅谈无线VLAN的设置]]></title>
        <id>https://blog.ikozn.com/post/DCN-浅谈无线VLAN的设置/</id>
        <link href="https://blog.ikozn.com/post/DCN-浅谈无线VLAN的设置/">
        </link>
        <updated>2018-03-12T07:22:14.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<p>首先我们来看一个常见的错误配置方式</p>
<h3 id="拓扑"><strong>拓扑</strong></h3>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2018/03/12/5aa600e2bb5a2.png" alt="拓扑" loading="lazy"></figure>
<br />
<br />
<h3 id="需求"><strong>需求</strong></h3>
<p>1.网络拓扑如上图所示，AC是无线控制器，其E1/0/1口连接着AP的LAN1口</p>
<p>2.按照 表1-1 完成无线网络的配置.使用户连接WLAN使能够获取对应VLAN的IP地址。AP地址通过DHCP下发，为192.168.3.10。</p>
<table>
<thead>
<tr>
<th>VLAN</th>
<th>SVI接口地址</th>
<th>说明</th>
<th>对应SSID</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>192.168.1.254/24</td>
<td>用户VLAN</td>
<td>VLAN1-Wireless-LAB</td>
</tr>
<tr>
<td>2</td>
<td>192.168.2.254/24</td>
<td>用户VLAN</td>
<td>VLAN2-Wireless-LAB</td>
</tr>
<tr>
<td>3</td>
<td>192.168.3.254/24</td>
<td>管理 and 用户VLAN</td>
<td>VLAN3-Wireless-LAB</td>
</tr>
</tbody>
</table>
<center>表1-1</center>
<h3 id="配置及实现"><strong>配置及实现</strong></h3>
<h4 id="1ap上线">1.AP上线</h4>
<br />
<h4 id="划分vlan和设置svi接口地址">划分VLAN和设置SVI接口地址</h4>
<pre><code>AC(config)#vlan 2		//创建VLAN2
AC(config-vlan2)#vlan 3		//创建VLAN3
AC(config-vlan3)#int vlan 1 	//进入Vlan1的SVI接口
AC(config-if-vlan1)#ip ad 192.168.1.254 255.255.255.0		//设置IP地址	
AC(config-if-vlan1)#int vlan 2		//进入VLAN2的SVI接口
AC(config-if-vlan2)#ip ad 192.168.2.254 255.255.255.0		//设置IP地址
AC(config-if-vlan2)#int vlan 3		//进入VLAN3的SVI接口
AC(config-if-vlan3)#ip ad 192.168.3.254 255.255.255.0		//设置IP地址
AC(config-if-ethernet1/0/1)#sw mo trunk 		//更改接口模式为Trunk
AC(config-if-vlan3)#int e1/0/1
AC(config-if-ethernet1/0/1)#sw mo trunk 
AC(config-if-ethernet1/0/1)#switchport trunk native vlan 3		//设置Native VLAN为VLAN3
</code></pre>
<br />
<br />
<h4 id="2-开启dhcp功能自动下发地址">2 开启DHCP功能，自动下发地址。</h4>
<pre><code>AC(config)#ip dhcp pool vlan1 		//创建地址池
AC(dhcp-vlan1-config)#network-address 192.168.1.0 255.255.255.0		//设置下发网段
AC(dhcp-vlan1-config)#default-router 192.168.1.254		
AC(dhcp-vlan1-config)#!
AC(config)#ip dhcp pool vlan2		//创建地址池
AC(dhcp-vlan2-config)#network-address 192.168.2.0 255.255.255.0		//设置下发网段
AC(dhcp-vlan2-config)#default-router 192.168.2.254 		//设置网关
AC(dhcp-vlan2-config)#!
AC(config)#ip dhcp pool vlan3       //创建地址池                
AC(dhcp-vlan3-config)#network-address 192.168.3.0 255.255.255.0		//设置下发网段
AC(dhcp-vlan3-config)#default-router 192.168.3.254		//设置网关
AC(dhcp-vlan3-config)#!
AC(config)#service dhcp		//开启DHCP服务
</code></pre>
<br />
<br />
<h4 id="3-dhcp静态绑定ap地址">3 DHCP静态绑定AP地址</h4>
<p><strong>AC</strong></p>
<pre><code>AC(config)#show ip dh binding 		//查看DHCP绑定
Total dhcp binding items: 1, the matched: 1
IP address          Hardware address         Lease expiration         Type
192.168.3.1         00-03-0F-5B-F0-E0        Mon Jan 02 00:30:00 2006 Dynamic

AC(config)#ip dhcp pool AP		//添加DHCP池
AC(dhcp-ap-config)#hardware-address 00-03-0F-5B-F0-E0		//绑定MAC地址
AC(dhcp-ap-config)#host 192.168.3.10		//绑定IP
AC(dhcp-ap-config)#default-router 192.168.3.254		//设置网关
AC(dhcp-ap-config)#!
AC(config)#show ip dh binding                
Total dhcp binding items: 1, the matched: 1
IP address          Hardware address         Lease expiration         Type
192.168.3.10        00-03-0F-5B-F0-E0        Infinite                 Manual
</code></pre>
<br />
<br />
<p><strong>AP</strong></p>
<p>重启的DHCP功能</p>
<pre><code>AP# set management dhcp-status down	//关闭DHCP获取地址
AP# set management dhcp-status up  	//开启DHCP获取地址
AP# get management 
Property                   Value
--------------------------------------------
vlan-id                    1
interface                  brvlan1
static-ip                  192.168.1.10
static-mask                255.255.255.0
ip                         192.168.3.10		//获取到了192.168.3.10
mask                       255.255.255.0
ipv6                       
ipv6-prefix-length         0
mac                        00:03:0F:5B:F0:E0
dhcp-status                up
dhcpv6-status              down
ipv6-status                up
ipv6-autoconfig-status     up
static-ipv6                
static-ipv6-prefix-length  0
</code></pre>
<br />
<br />
<h4 id="4-开启ac无线功能">4 开启AC无线功能</h4>
<pre><code>AC(config-wireless)#no auto-ip-assign 		//关闭无线地址选举
AC(config-wireless)#static-ip 192.168.3.254		//设置静态无线地址
AC(config-wireless)#discovery vlan-list 3		//设置二层发现VLAN
AC(config-wireless)#ap authentication none 		//关闭AP验证
AC(config-wireless)#enable 		//开启无线功能
查看AP状态
AC(config)#show wir ap status 

    MAC Address                                                            Configuration                
 (*) Peer Managed  IP Address                              Profile Status     Status           Age      
------------------ --------------------------------------- ------- ------- ------------- --------------
 00-03-0f-5b-f0-e0 192.168.3.10                            1       Managed Failure       0d:00:00:07

Total Access Points............................ 1
</code></pre>
<br />
<br />
<h4 id="5-无线配置">5 无线配置</h4>
<pre><code>AC(config)#wireless 		//进入无线全局模式
AC(config-wireless)#network 1		//进入network配置模式
AC(config-network)#ssid VLAN1-Wireless-LAB		//设置SSID
AC(config-network)#security mode none 	//关闭用户认证
AC(config-network)#vlan 1		//设置VLAN
AC(config-network)#network 2		//进入network配置模式
AC(config-network)#ssid VLAN2-Wireless-LAB
AC(config-network)#security mode none 		//关闭用户认证
AC(config-network)#vlan 2		//设置VLAN
AC(config-network)#network 3		//进入network配置模式
AC(config-network)#ssid VLAN3-Wireless-LAB
AC(config-network)#security mode none 		//关闭用户认证
AC(config-network)#vlan 3		//设置VLAN
AC(config-network)#!
AC(config-wireless)#ap profile 1		//进入profile 1
AC(config-ap-profile)#hwtype 29		//设置硬件号
AC(config-ap-profile)#radio 1		//进入radio配置模式
AC(config-ap-profile-radio)#vap 1		//进入vap配置模式
AC(config-ap-profile-vap)#enable 		//开启vap
AC(config-ap-profile-vap)#vap 2		//进入VAP配置模式
AC(config-ap-profile-vap)#enable 	//开启VAP
AC(config-ap-profile-vap)#!
AC(config-ap-profile-radio)#!
AC(config-ap-profile)#!
AC(config-wireless)#!
AC(config)#!
AC(config)#exit
AC#wir ap prof ap 1		//下发配置文件
All configurations will be send to the aps associated to this profile and associated clients on these aps will be disconnected. Are you sure you want to apply the profile configuration? [Y/N] y
</code></pre>
<hr>
<h4 id="6测试">6.测试</h4>
<p>配置文件下发之后，稍等一会，就可以搜索到无线信号了。</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2018/03/12/5aa57b1fe9738.png" alt="WIFI列表" loading="lazy"></figure>
<p>接着我们连上去试试</p>
<p>首先我们连接VLAN1的</p>
<p>结果发现</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2018/03/12/5aa57c1f5f96d.png" alt="VLAN1连接" loading="lazy"></figure>
<center>竟然获取到了VLAN3的地址</center>
<br />
<center>接下来我们再连接VLAN2的试试</center>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2018/03/12/5aa57c1f5f96d.png" alt="VLAN2连接" loading="lazy"></figure>
<center>发现是正常的</center>
<br />
<center>最后再来连接VLAN3</center>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2018/03/12/5aa58ea17ceb9.png" alt="VLAN3连接" loading="lazy"></figure>
<center>发现根本获取不到IP地址</center>
<h3 id="问题分析">问题分析</h3>
<h4 id="1拓扑">1.拓扑</h4>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2018/03/12/5aa600e2bb5a2.png" alt="拓扑" loading="lazy"></figure>
<br />
<br />
<h4 id="2vlan-1-用户上线过程">2.VLAN 1 用户上线过程</h4>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2018/03/12/5aa600abe2514.png" alt="VLAN DHCP过程" loading="lazy"></figure>
<p>**(1).**当用户连接到无线网络之后，客户端发送<code>DHCP DISCOVER</code>广播包来请求IP地址</p>
<p>**(2).**AP默认的转发方式为本地转发，所以<code>DHCP DISCOVER</code>报文到达AP之后802.11帧便被转换成以太网帧。不打VLAN TAG，将数据包转发给交换机。</p>
<p>**(3).**我们在交换机的E1/0/1接口上配置了命令 <code>switchport trunk native vlan 3</code>,所以当没有VLAN Tag的帧到达交换机的时候，被打上VLAN 3的标签.</p>
<p>**(4).**所以最后导致了Client获取到了VLAN3网段的地址</p>
<blockquote>
<p>VLAN1的数据AP不打标签</p>
</blockquote>
<br />
<br />
<h4 id="3vlan-2-用户上线过程">3.VLAN 2 用户上线过程</h4>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2018/03/12/5aa601ee7c5d5.png" alt="VLAN2上线" loading="lazy"></figure>
<p>**(1).**当用户连接到无线网络之后，客户端发送<code>DHCP DISCOVER</code>广播包来请求IP地址</p>
<p>**(2).**AP默认的转发方式为本地转发，所以<code>DHCP DISCOVER</code>报文到达AP之后802.11帧便被转换成以太网帧。</p>
<p>打上<code>VLAN 2</code> TAG，将数据包转发给交换机。</p>
<p>**(3).**交换机收到该帧，不对帧进行任何处理，直接放行，最后帧在VLAN2内传播。</p>
<p>**(4).**所以客户机可以获取到正确的地址。</p>
<br />
<br />
<h4 id="4vlan-3-用户上线过程">4.VLAN 3 用户上线过程</h4>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2018/03/12/5aa60313a8a84.png" alt="VLAN3上线" loading="lazy"></figure>
<p>**(1).**当用户连接到无线网络之后，客户端发送<code>DHCP DISCOVER</code>广播包来请求IP地址</p>
<p>**(2).**AP默认的转发方式为本地转发，所以<code>DHCP DISCOVER</code>报文到达AP之后802.11帧便被转换成以太网帧。</p>
<p>**(3).**打上<code>VLAN 3</code> TAG，将数据包转发给交换机，然而交换机上配置了<code>switchport trunk native vlan 3</code>，导致交换机丢包，该SSID下所有数据都不能通过交换机，所以最终也不能获取地址。</p>
<br />
<br />
<hr>
<h3 id="解决问题">解决问题</h3>
<p>让我们重新做一遍</p>
<h4 id="1设置vlan">1.设置VLAN</h4>
<pre><code>AC(config)#vlan 2		//创建VLAN2
AC(config-vlan2)#vlan 3		//创建VLAN3
AC(config-vlan3)#int vlan 1 	//进入Vlan1的SVI接口
AC(config-if-vlan1)#ip ad 192.168.1.254 255.255.255.0		//设置IP地址	
AC(config-if-vlan1)#int vlan 2		//进入VLAN2的SVI接口
AC(config-if-vlan2)#ip ad 192.168.2.254 255.255.255.0		//设置IP地址
AC(config-if-vlan2)#int vlan 3		//进入VLAN3的SVI接口
AC(config-if-vlan3)#ip ad 192.168.3.254 255.255.255.0		//设置IP地址
AC(config-if-vlan3)#int e1/0/1
AC(config-if-ethernet1/0/1)#sw mo trunk 		//更改接口模式为Trunk
</code></pre>
<p><strong>注意，这里不设置Native VLAN</strong></p>
<br />
<br />
<h4 id="2设置dhcp">2.设置DHCP</h4>
<p><strong>AP</strong></p>
<p>设置管理VLAN</p>
<pre><code>AP# set management vlan-id 3	//设置管理VLAN为VLAN3
</code></pre>
<blockquote>
<p>设置管理VLAN之后，从AP发出的管理/控制报文都会打上VLAN 3的TAG，也可以接受带VLAN3 TAG的管理报文。</p>
</blockquote>
<br />
<br />
<p><strong>AC</strong></p>
<pre><code>AC(config)#ip dh pool VLAN1
AC(dhcp-vlan1-config)#network-address 192.168.1.0 255.255.255.0
AC(dhcp-vlan1-config)#default-router 192.168.1.254
AC(dhcp-vlan1-config)#!                    
AC(config)#ip dh pool VLAN2
AC(dhcp-vlan2-config)#network-address 192.168.2.0 255.255.255.0
AC(dhcp-vlan2-config)#default-router 192.168.2.254
AC(dhcp-vlan2-config)#!
AC(config)#ip dh pool VLAN3
AC(dhcp-vlan3-config)#network-address 192.168.3.0 255.255.255.0
AC(dhcp-vlan3-config)#default-router 192.168.3.254
AC(dhcp-vlan3-config)#!
AC(config)#service dhcp
</code></pre>
<br />
<br />
<h4 id="3静态绑定dhcp">3.静态绑定DHCP</h4>
<p><strong>AC</strong></p>
<pre><code>AC(config)#show ip dh binding 
Total dhcp binding items: 1, the matched: 1
IP address          Hardware address         Lease expiration         Type
192.168.3.1         aa-aa-aa-aa-aa-aa        Mon Jan 02 00:12:00 2006 Dynamic
AC(config)#ip dhcp pool AP
AC(dhcp-ap-config)#hardware-address aa-aa-aa-aa-aa-aa
AC(dhcp-ap-config)#host 192.168.3.10
AC(dhcp-ap-config)#default-router 192.168.3.254
AC(dhcp-ap-config)#!
</code></pre>
<br />
<p><strong>AP</strong></p>
<pre><code>AP# set management dhcp-status down
AP# set management dhcp-status up  
</code></pre>
<br />
<br />
<h4 id="4开启无线功能">4.开启无线功能</h4>
<pre><code>AC(config-wireless)#no auto-ip-assign 
AC(config-wireless)#static-ip 192.168.3.254
AC(config-wireless)#ap authe none 
AC(config-wireless)#discovery vlan-list 3
AC(config-wireless)#enable 
</code></pre>
<br />
<br />
<h4 id="5配置无线">5.配置无线</h4>
<pre><code>AC(config-wireless)#network 1
AC(config-network)#ssid VLAN1-Wireless-LAB
AC(config-network)#vlan 1
AC(config-network)#network 2
AC(config-network)#ssid VLAN2-Wireless-LAB
AC(config-network)#vlan 2
AC(config-network)#network 3
AC(config-network)#ssid VLAN3-Wireless-LAB
AC(config-network)#vlan 3
AC(config-network)#!
AC(config-wireless)#ap profile 1
AC(config-ap-profile)#hwtype 29
AC(config-ap-profile)#management vlan 3
AC(config-ap-profile)#radio 1
AC(config-ap-profile-radio)#vap 1
AC(config-ap-profile-vap)#enable 
AC(config-ap-profile-vap)#vap 2
AC(config-ap-profile-vap)#enable 
AC(config-ap-profile-vap)#!
AC(config-ap-profile-radio)#!
AC(config-ap-profile)#!
AC#wireless ap prof ap 1
All configurations will be send to the aps associated to this profile and associated clients on these aps will be disconnected. Are you sure you want to apply the profile configuration? [Y/N] y
AP Profile apply is in progress.
</code></pre>
<br />
<br />
<h4 id="6测试-2">6.测试</h4>
<p><strong>VLAN1</strong></p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2018/03/12/5aa60f0615b3b.png" alt="VLAN1" loading="lazy"></figure>
<br />
<br />
<p><strong>VLAN2</strong></p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2018/03/12/5aa60f8f5b204.png" alt="VLAN2" loading="lazy"></figure>
<p><strong>VLAN3</strong></p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2018/03/12/5aa61045a552d.png" alt="VLAN3" loading="lazy"></figure>
<p>可以发现，这次一切都正常了。</p>
<hr>
<h3 id="失误发生的原因">失误发生的原因</h3>
<p>这个配置错误出现的原因主要有以下两点:</p>
<p>**1.**对<code>network</code>配置模型下<code>vlan</code>的命令有所误解</p>
<p>这个命令是设置VLAN表示，设置无线用户的数据在经过AP之后应打上的VLAN TAG，而不是说这个无线信号数据是哪个VLAN，就设置成哪个VLAN。</p>
<br />
<br />
<p>**2.**无线管理VLAN的设置</p>
<p>一般来说，我们设置管理VLAN的时候都是将接口设置为Trunk，并更改接口的本征VLAN.大多数情况下这样子是没有问题的.但是当管理VLAN和用户VLAN是同一个，并且不是VLAN1的时候，情况就有些尴尬.</p>
<p>如上面的第一个实验，当管理和用户VLAN都是VLAN3的时候，我们一般都是这么设置的:</p>
<pre><code>AC(config-if-vlan3)#int e1/0/1
AC(config-if-ethernet1/0/1)#sw mo trunk 
AC(config-if-ethernet1/0/1)#switchport trunk native vlan 3		//设置Native VLAN为VLAN3
</code></pre>
<p><em><strong>更改接口的本征VLAN</strong></em></p>
<br />
<br />
<pre><code>AC(config-network)#network 3		//进入network配置模式
AC(config-network)#ssid VLAN3-Wireless-LAB
AC(config-network)#security mode none 		//关闭用户认证
AC(config-network)#vlan 3		//设置VLAN
</code></pre>
<p><em><strong>在Network下设置VLAN标识</strong></em></p>
<p>如果这么设置，AP转发连接到Network 3的用户流量的时候，就会打上VLAN 3的TAG并发送出去，然而我们的AC接口也将接口的本征VLAN修改为了VLAN3。一但AC收到AP发来带有VLAN 3 TAG的数据帧时，就会将帧丢弃，这就这就导致了我们连上了Network 3却无法访问网络.</p>
<br />
<br />
<p>解决方法有两种</p>
<p>**1.**将network中的vlan标识改回vlan1</p>
<p>如此，当AP转发Network的流量时，就不会打上VLAN TAG，AC接收到数据帧之后，会根据本征VLAN打上VLAN TAG，然后在AC中进行转发。</p>
<p>此方法的代价就是VLAN1不能用来转发无线流量(不能当做用户VLAN).</p>
<br />
<p>**2.**请看[解决问题]篇</p>
<h3 id="总结">总结</h3>
<p>当你的管理VLAN与用户VLAN是同一个VLAN且不是VLAN1的时候，要么放弃使用VLAN1转发数据。</p>
<p>要么在AP上设置管理VLAN.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[DCN]神州数码无线常用配置]]></title>
        <id>https://blog.ikozn.com/post/无线常用配置/</id>
        <link href="https://blog.ikozn.com/post/无线常用配置/">
        </link>
        <updated>2018-03-11T15:21:33.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="ap管理">AP管理</h3>
<h4 id="ac发现ap">AC发现AP</h4>
<h5 id="二层发现">二层发现</h5>
<pre><code>DCWS-6028(P)(config-wireless)#discovery vlan-list 1 //指定VLAN发现列表
DCWS-6028(P)(config-wireless)# ap database xx-xx-xx-xx-xx-xx  //添加AP MAC地址
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h3 id="ap管理">AP管理</h3>
<h4 id="ac发现ap">AC发现AP</h4>
<h5 id="二层发现">二层发现</h5>
<pre><code>DCWS-6028(P)(config-wireless)#discovery vlan-list 1 //指定VLAN发现列表
DCWS-6028(P)(config-wireless)# ap database xx-xx-xx-xx-xx-xx  //添加AP MAC地址
</code></pre>
<!--more-->
<h5 id="三层发现">三层发现</h5>
<h4 id="ap发现ac">AP发现AC</h4>
<p><em><strong>AP配置</strong></em></p>
<pre><code>DCN-WLAN-AP# set management static-ip 192.168.2.1  //配置静态IP
DCN-WLAN-AP# set management static-mask 255.255.255.0  //配置掩码
DCN-WLAN-AP# set static-ip-route gateway 192.168.2.2   //配置默认网关
</code></pre>
<p><em><strong>AC配置</strong></em></p>
<pre><code>DCWS-6028(P)(config-wireless)# discovery ip-list 192.168.2.1  //指定AP IP
DCWS-6028(P)(config-wireless)# ap database xx-xx-xx-xx-xx-xx  //添加AP MAC地址
</code></pre>
<h5 id="ap静态发现">AP静态发现</h5>
<pre><code>DCN-WLAN-AP# set managed-ap switch-address-1 192.168.1.1	//设置第一个AC地址
DCN-WLAN-AP# set managed-ap switch-address-2 192.168.2.2	//设置第二个AC地址
</code></pre>
<h5 id="option下发ac地址">Option下发AC地址</h5>
<pre><code>DCWS(config)#ip dhcp pool ap
DCWS(dhcp-ap-config)#option 43 hex 01040A090005	//0104为固定值，后接IP地址16进制
</code></pre>
<h4 id="ap认证">AP认证</h4>
<h5 id="无验证">无验证</h5>
<pre><code>DCWS(config-wireless)#ap authentication none
</code></pre>
<h5 id="mac地址验证">MAC地址验证</h5>
<pre><code>DCWS(config-wireless)#ap authe mac //设置AP验证方式为mac地址验证
DCWS(config-wireless)#ap database xx-xx-xx-xx-xx-xx //手动添加AP database 条目
</code></pre>
<h5 id="密码验证">密码验证</h5>
<p><em><strong>AP配置</strong></em></p>
<pre><code>AP# set managed-ap pass-phrase 12345678	//设置认证密码
</code></pre>
<p><em><strong>AC配置</strong></em></p>
<pre><code>DCWS(config-wireless)#ap authentication pass-phrase 
DCWS(config-wireless)#ap database xx-xx-xx-xx-xx-xx            
DCWS(config-ap)#password plain 12345678	//设置AP认证密码
</code></pre>
<h5 id="序列号认证">序列号认证</h5>
<p><em><strong>AP操作</strong></em></p>
<pre><code>AP# get system 
Property          Value
---------------------------------------------------------------
model             Wireless Infrastructure Platform Reference AP
version           2.0.20.15
altversion        2.0.20.15
protocol-version  2
base-mac          xx:xx:xx:xx:xx:xx
serial-number     WL013210FA24000118	//序列号
system-name       
system-contact    
system-location   
apmode            fit
</code></pre>
<p><em><strong>AC操作</strong></em></p>
<pre><code>AC(config)#wireless 
AC(config-wireless)# ap authentication serial-num
AC(config-wireless)# ap database xx-xx-xx-xx-xx-xx 
AC(config-ap)#serial-num WL013210FA24000118
</code></pre>
<h4 id="ap逃生">AP逃生</h4>
<pre><code>DCWS(config-wireless)#ap prof 1
DCWS(config-ap-profile)#ap escape //开启AP逃生模式
</code></pre>
<h4 id="修改ap配置文件">修改AP配置文件</h4>
<pre><code>AC(config-ap)#profile 3 //在AP配置模式下()
</code></pre>
<h4 id="修改ap管理vlan">修改AP管理VLAN</h4>
<pre><code>AC(config-ap-profile)#management vlan 4094 
AC(config-ap-profile)#wireless ap profile apply 1
</code></pre>
<hr>
<h3 id="用户接入">用户接入</h3>
<h4 id="用户认证方式">用户认证方式</h4>
<h5 id="wep认证">WEP认证</h5>
<pre><code>DCWS(config-network)#Sec mode static-wep 	//设置认证方式为WEP
DCWS(config-network)#wep key length 64		//设置key长度，64为5位，128为13位
DCWS(config-network)#wep key type ascii		//设置WEP密钥类型
DCWS(config-network)#wep key  1 12345		//设置WEP密钥
</code></pre>
<h5 id="wpa个人版">WPA个人版</h5>
<pre><code>DCWS(config-wireless)#network 1
DCWS(config-network)#Sec mode wpa-per 	//设置认证方式为WPA个人版
DCWS(config-network)#wpa ciphers tkip 	//设置WPA加密方式为Tkip
DCWS(config-network)#wpa key tikp123456789	//设置WPA密钥
</code></pre>
<h5 id="wpa企业版">WPA企业版</h5>
<p><em><strong>认证服务器配置</strong></em></p>
<blockquote>
<p>略</p>
</blockquote>
<p><em><strong>AC配置</strong></em></p>
<pre><code>DCWS(config)#dot1x enable      //开启dot1x认证
DCWS(config)#radius-server authentication host 172.16.5.164 key 0 123 //设置服务器地址和key
DCWS(config)#radius source-ipv4 172.16.5.233  //设置源地址
DCWS(config)#radius nas-ipv4 172.16.5.233     //设置NAS地址
DCWS(config)#aaa enable
DCWS(config)#!
DCWS(config)#aaa group server radius 2012    //设置AAA组
DCWS(config-sg-radius)# server 172.16.5.164    //添加服务器
DCWS(config-sg-radius)#!
DCWS(config)#wireless
DCWS(config-wireless)# radius server-name auth 2012 //调用AAA服务器组
DCWS(config-wireless)# network 1
DCWS(config-network)#  radius server-name auth 2012    //调用AAA服务器组
DCWS(config-network)#  security mode wpa-enterprise    //设置无线企业认证
DCWS(config-network)#  ssid radius
DCWS(config-network)#  vlan 20
DCWS(config-network)#!
</code></pre>
<h4 id="本地portal认证">本地Portal认证</h4>
<pre><code>AC(config)#captive-portal    //进入captive-portal模式
AC(config-cp)#enable    //开启Protal功能
AC(config-cp)#authentication-type internal    //认证类型为内置Protal
AC(config-cp)#user user1    //创建并设置用户 user1
AC(config-cp-local-user)#password 123456    //设置账户的密码为 123456
AC(config-cp-local-user)#group 0    //用户加入组 group 0
AC(config-cp-local-user)#!
AC(config-cp)#configuration 1    //进入captive-portal 配置1
AC(config-cp-instance)#enable    //开启此配置
AC(config-cp-instance)#verification local    //设置验证模式为本地
AC(config-cp-instance)#group 0    //绑定Group 0 组
AC(config-cp-instance)#auth-method mac-ip-based    //设置认证方式为基于MAC-IP
AC(config-cp-instance)#interface ws-network 1    //绑定无线网络 (对应配置下发时的 Network 对应一个VAP)
</code></pre>
<h4 id="动态黑名单">动态黑名单</h4>
<pre><code>DCWS(config-wireless)#dynamic-blacklist //开启动态黑名单功能
DCWS(config-wireless)#network 1
DCWS(config-network)#mac authentication local //开启MAC本地验证
</code></pre>
<h4 id="mac认证">MAC认证</h4>
<blockquote>
<p>只允许已添加MAC的终端连接AP，或阻止已添加MAC的终端连接AP</p>
</blockquote>
<p>只允许已添加MAC的终端连接AP</p>
<pre><code>DCWS-6028(config-wireless)#mac-authentication-modewhite-list	//开启MAC白名单模式
DCWS-6028(config-wireless)#known-client 00-11-11-11-11-11 action global-action	//添加MAC地址
DCWS-6028(config-wireless)#network 1
DCWS-6028(config-network)#mac authentication local	//开启MAC本地认证
</code></pre>
<p>阻止已添加MAC的终端连接AP</p>
<pre><code>DCWS-6028(config-wireless)#mac-authentication-modeblack-list	//开启黑名单模式
DCWS-6028(config-wireless)#known-client 00-22-22-22-22-22action global-action	//添加MAC地址
DCWS-6028(config-wireless)#network 1
DCWS-6028(config-network)#mac authentication local	//开启MAC本地认证
</code></pre>
<p>配置完成后需下发AP生效</p>
<pre><code>DCWS-6028#wireless approfile apply 1
</code></pre>
<h4 id="最大接入用户数">最大接入用户数</h4>
<p>最大接入10个用户</p>
<pre><code>DCWS(config-network)#max-clients 10 
</code></pre>
<p>用户老化时间为300秒</p>
<pre><code>DCWS(config-network)#offline-detect idle-timeout 300
</code></pre>
<h4 id="限制接入时间">限制接入时间</h4>
<p>星期一 09:00 到 18:00 不允许接入无线网络</p>
<pre><code>DCWS(config-network)#time-limit from 09:00 to 18:00 weekday monday 
</code></pre>
<h4 id="arp抑制">ARP抑制</h4>
<pre><code>AC(config)# wireless 
AC(config-wireless)#network 1 
AC(config-network)# arp-suppression
</code></pre>
<h4 id="anti-flood">Anti-flood</h4>
<p>防止AP泛洪攻击，检测时间为10分钟，最大连接次数为5次，老化时间为60分钟</p>
<pre><code>AC(config-wireless)# wireless ap anti-flood
AC(config-wireless)# wireless ap anti-flood interval 10
AC(config-wireless)# wireless ap anti-flood max-conn-count 5
AC(config-wireless)# wireless ap anti-flood agetime 60
</code></pre>
<h4 id="隐藏ssid">隐藏SSID</h4>
<pre><code>DCWS(config-network)#hide-ssid 
</code></pre>
<hr>
<h3 id="射频管理">射频管理</h3>
<h4 id="调整射频工作模式">调整射频工作模式</h4>
<pre><code>DCWS-6028(config-wireless)#ap profile 1
DCWS-6028(config-ap-profile)#radio 1
DCWS-6028(config-ap-profile-radio)#mode bg-n
</code></pre>
<h4 id="设置ap的功率和信道">设置AP的功率和信道</h4>
<p>调整完需重启AP生效</p>
<pre><code>DCWS-6028(config-wireless)#ap database 00-03-0f-19-71-e0
DCWS-6028(config-ap)#radio 1 channel 11
The valid AP entry is updated. This AP is already managed, to update the managed AP configuration with the new value(s) you need to reset the AP.
DCWS-6028(config-ap)#radio 1 power 50
</code></pre>
<h4 id="自动信道调整">自动信道调整</h4>
<blockquote>
<p>自动信道调整有三种方式：手动触发、周期性触发和固定时间触发</p>
<p>如果为AP设置了固定信道，则不能对此AP进行自动信道调整</p>
<p>自动信道调整功能默认是开启的</p>
</blockquote>
<h5 id="手动触发方式">手动触发方式</h5>
<pre><code>DCWS-6028(config-wireless)#channel-planbgn mode manual 
DCWS-6028#wireless channel-plan bgnstart
wirelessCalculate80211ChannelAdjustment successfuly added proposed entry to ap=00-03-0f-19-71-e0
  
DCWS-6028#wirelesschannel-plan bgn apply
</code></pre>
<h5 id="周期性触发方式">周期性触发方式</h5>
<pre><code>DCWS-6028(config-wireless)#channel-plan bgnmode interval
DCWS-6028(config-wireless)#channel-plan bgninterval 720
</code></pre>
<h5 id="固定时间触发方式">固定时间触发方式</h5>
<pre><code>DCWS-6028(config-wireless)#channel-plan bgnmode time
DCWS-6028(config-wireless)#channel-plan bgntime 23:00
</code></pre>
<h4 id="自动功率调整">自动功率调整</h4>
<blockquote>
<p>自动功率调整有两种方式：手动触发和周期性触发</p>
<p>如果为AP配置了固定功率，则不能对此AP进行自动功率调整</p>
</blockquote>
<h5 id="手动触发方式-2">手动触发方式</h5>
<pre><code>DCWS-6028(config-wireless)#ap profile 1
DCWS-6028(config-ap-profile)#radio 1
DCWS-6028(config-ap-profile-radio)#power auto 
DCWS-6028(config-wireless)#power-plan mode manual
DCWS-6028#wireless power-plan start
DCWS-6028#wireless power-plan apply
</code></pre>
<h5 id="周期性触发方式-2">周期性触发方式</h5>
<pre><code>DCWS-6028(config-wireless)#approfile 1
DCWS-6028(config-ap-profile)#radio 1
DCWS-6028(config-ap-profile-radio)#power auto 
DCWS-6028(config-ap-profile-radio)#exit
DCWS-6028(config-ap-profile)#exit
DCWS-6028(config-wireless)#power-plan mode interval 
DCWS-6028(config-wireless)#power-plan interval 720
</code></pre>
<h4 id="支持速率集">支持速率集</h4>
<pre><code>AC(config- ap-profile-radio)#mode bg 
AC(config- ap-profile-radio)#rate basic 54 //设置基本速率集
DCWS(config-ap-profile-radio)#rate supported 54 //设置支持速率集
</code></pre>
<hr>
<h3 id="流量转发">流量转发</h3>
<h4 id="无线隔离">无线隔离</h4>
<p>同一SSID(同一VLAN)下无线隔离</p>
<pre><code>DCWS(config-wireless)#network 1
DCWS(config-network)#station-isolation 
</code></pre>
<p>同一radio下用户隔离</p>
<pre><code>DCWS(config-wireless)#ap profile 1
DCWS(config-ap-profile)#radio 1
DCWS(config-ap-profile-radio)#station-isolation
</code></pre>
<h4 id="无线强制漫游">无线强制漫游</h4>
<pre><code>DCWS(config-wireless)#force-roaming mode auto //开启自动强制漫游功能
DCWS(config-wireless)#force-roaming mode auto interval 15  //自动强制漫游功能的执行周期为15分钟。
DCWS(config-wireless)#force-roaming rssi-threshold 10   //设置RSSI阈值，为10%
DCWS(config-wireless)#force-roaming denial-count 5       //设置自动强制漫游拒绝次数门限为5次
DCWS(config-wireless)#force-roaming denial-timeout 1  //设置拒绝次数门限老化为1小时
DCWS(config-wireless)#force-roaming hysteresis 4    //设置符合强制漫游的信号强度差值为4%.
DCWS#wireless force-roaming client aa-aa-aa-aa-aa-aa start  //手动发起漫游功能
</code></pre>
<h4 id="分布式转发">分布式转发</h4>
<pre><code>DCWS-6028(P)(config-network)#dist-tunnel //该Network的流量开启分布式转发
</code></pre>
<h4 id="集中转发">集中转发</h4>
<pre><code>DCWS(config-wireless)#l2tunnel vlan-list add 10;20	//设置VLAN10 VLAN20的流量为集中转发
</code></pre>
<h4 id="限速">限速</h4>
<pre><code>DCWS(config-wireless)#ap client-qos	//开启AP QoS
DCWS(config-wireless)#network 1
DCWS(config-network)#client-qos bandwidth-limit down 5120	//限速下行速率为5Mb/s
DCWS(config-network)#client-qos bandwidth-limit up 2048		//限速上行速率为2Mb/s
</code></pre>
<h4 id="时空公平调度">时空公平调度</h4>
<pre><code>DCWS(config-ap-profile-radio)#schedule-mode preferred	//开启时空公平调度
</code></pre>
<hr>
<h3 id="常用维护命令">常用维护命令</h3>
<h4 id="ac常用维护命令">AC常用维护命令</h4>
<p><strong>查看AP的注册和配置状态</strong></p>
<pre><code>DCWS-6028#show wireless ap status 
	    MAC Address                                            Configuration                
	 (*) Peer Managed  IP Address Profile Status     Status           Age      
	------------------ --------------- ------- ------- ------------- -------------- -------------
	 00-03-0f-19-71-e0 192.168.1.10    1  Managed Success   d:00:00:01
	Total Access Points............................ 1

</code></pre>
<p><strong>查看AP的注册失败信息</strong></p>
<pre><code>DCWS-6028#show wireless ap failure status
</code></pre>
<p><strong>下发配置</strong></p>
<pre><code>DCWS-6028#wireless approfile apply 1
</code></pre>
<p><strong>设置硬件类型</strong></p>
<pre><code>DCWS(config-ap-profile)#hwtype 29
</code></pre>
<p><strong>查看硬件版本</strong>1</p>
<pre><code>DCWS(config-ap-profile)#show wir ap 00-03-0f-5b-f0-e0 status | i Type
Hardware Type.................................. 29 - WL8200-I2, Indoor Dual Radio a/n/ac, b/g/n
CPU Type....................................... AR9344-533
</code></pre>
<p><strong>查看硬件版本2</strong></p>
<pre><code>DCWS#show vendor | i WL8200-I2
                          29 WL8200-I2        R1    WL8200-I2, Indoor Dual Radio a/n/ac, b/g/n
</code></pre>
<p>查看AC的无线状态，可以看到无线功能是否开启，无线IP地址信息，国家代码信息，管理的AP数量等</p>
<pre><code>DCWS-6028# show wireless 
DCWS-6028# show wireless status
</code></pre>
<p>查看AP的详细信息，可以看到AP的MAC地址、IP地址、硬件类型及型号、软件版本、序列号等</p>
<pre><code>DCWS-6028#showwireless ap 00-03-0f-19-71-e0 status 
  MACaddress.................................... 00-03-0f-19-71-e0
  Location.......................................
  IPAddress..................................... 192.168.1.10
  IP SubnetMask................................. 255.255.255.0
  … …
</code></pre>
<p>查看AP的射频信息</p>
<pre><code>DCWS-6028#show wireless ap radio status 
	 DCWS-6028#show wireless ap 00-03-0f-19-71-e0 radio status 
	     MAC Address                                                     Transmit     Auth. 
	 (*) Peer Managed   Location        Radio Channel Power (%) Clients
	     ------------------       -----------          -----       -------    --------         -------
	 00-03-0f-19-71-e0                           1           11          100            0      
                                                                  2          149         100            0

</code></pre>
<p>查看无线终端信息</p>
<pre><code>DCWS-6028#show wireless client status      
	   MAC Address                                                             
	 (*) Peer Managed  VAP MAC Address SSID  Status Network Time 
 	     ------------------            -----------------          -------   ---------      -----------
	 00-1c-bf-21-85-90 00-03-0f-19-71-e1       wlan    Auth    0d:00:00:05
	Total Clients Associated To Local Switch....... 1
	Total Clients Associated To Peer Switches...... 0
</code></pre>
<p>重启AP，可以重启所有AP，也可以单独重启某一台AP</p>
<pre><code>DCWS-6028#wireless ap reset
DCWS-6028#wireless ap reset 00-03-0f-19-71-e0
</code></pre>
<h4 id="ap常用维护命令">AP常用维护命令</h4>
<p><strong>获取地址信息</strong></p>
<pre><code>AP# get management 
Property                   Value
--------------------------------------------
vlan-id                    1
interface                  brvlan1
static-ip                  192.168.2.1
static-mask                255.255.255.0
ip                         192.168.2.1
mask                       255.255.255.0
ipv6                       
ipv6-prefix-length         0
mac                        xx:xx:xx:xx:xx:xx
dhcp-status                up
dhcpv6-status              up
ipv6-status                up
ipv6-autoconfig-status     up
static-ipv6                
static-ipv6-prefix-length  0
</code></pre>
<p><strong>设置IP地址信息</strong></p>
<pre><code>AP# set management static-ip 192.168.2.1 //设置IP
AP# set static-ip-route management gateway 192.168.2.254    //配置网关
AP# set management static-mask 255.255.255.0  //设置掩码
AP# set management dhcp-status down //关闭DHCP
AP# set management dhcp-status up   //开启DHCP
AP# set managed-ap switch-address-1 1.1.1.1 //设置主AC地址
AP# set managed-ap switch-address-2 2.2.2.2 //设置备用AC地址
AP# set managed-ap switch-address-2 3.3.3.3 //设置备用AC地址
</code></pre>
<p><strong>设置管理VLAN</strong></p>
<pre><code>AP# set management vlan-id 1
</code></pre>
<p>**重置AP **</p>
<pre><code>DCN-WLAN-AP# factory-reset 
</code></pre>
<p>瘦AP转胖AP</p>
<pre><code>AP#switch-apmode fat
</code></pre>
<p>胖AP转瘦AP</p>
<pre><code>AP#switch-apmode fit
</code></pre>
<hr>
<h3 id="配置原则关系图解">配置原则关系图解</h3>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2018/03/11/5aa536dc8b2bb.png" alt="无线配置原则" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 我回来啦]]></title>
        <id>https://blog.ikozn.com/post/我胡汉三回来了/</id>
        <link href="https://blog.ikozn.com/post/我胡汉三回来了/">
        </link>
        <updated>2017-12-17T12:09:00.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="新的开始我胡汉三又回来了">新的开始，我胡汉三又回来了！</h3>
<p>前几个月原域名被墙，导致许多朋友都上不来.</p>
<p>在经过一段时间的忙碌之后，终于有空闲的时间来修复了，在这里给大家说一声抱歉。</p>
<p>不过，这都不重要！重要的是我终于回来了！并且还做了一些微小的改动。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="新的开始我胡汉三又回来了">新的开始，我胡汉三又回来了！</h3>
<p>前几个月原域名被墙，导致许多朋友都上不来.</p>
<p>在经过一段时间的忙碌之后，终于有空闲的时间来修复了，在这里给大家说一声抱歉。</p>
<p>不过，这都不重要！重要的是我终于回来了！并且还做了一些微小的改动。</p>
<!--more-->
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2018/03/31/5abf6be5c37d6.png" alt="骄傲" loading="lazy"></figure>
<h3 id="域名">域名</h3>
<p>由于之前的域名被墙了，所以把 <code>nayo.moe</code> 换成了 <code>ikozn.com</code>。</p>
<h3 id="博客程序">博客程序</h3>
<p>从 WordPress 换到了 Hexo,并且托管于 Coding，所有文章都又Markdown编写，实际使用起来还是不错的。</p>
<p>这次迁移之后，加上了<a href="http://www.google.com/analytics/">Google Analytics </a>的网站统计服务。</p>
<p>但是这都 <strong>不! 重! 要!</strong></p>
<p>最最最最最重要的是，这个可爱的看板娘！！！</p>
<figure data-type="image" tabindex="2"><img src="https://img.ikozn.com/images/AbMa.png" alt="看板娘" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://img.ikozn.com/images/AmJ2.jpg" alt="" loading="lazy"></figure>
<p>哎呀好可爱！</p>
<p>这可是费了我九牛二虎之力才弄上来的</p>
<p>对于一个不会开发的运维小萌新来说，这简直是个奇迹！</p>
<h3 id="博客名">博客名</h3>
<p>由于域名都换了，博客名自然而然的也换成了Ikozn,图床也就直接叫图床好了！</p>
<h3 id="文章">文章</h3>
<p>暂时只恢复了一些文章用于测试，之后会陆续的恢复更多的文章。</p>
<p>有一些质量不是很好的旧文章，和一些转载的文章，都删了，留下来也没有什么意义。</p>
<figure data-type="image" tabindex="4"><img src="https://img.ikozn.com/images/A6eJ.jpg" alt="" loading="lazy"></figure>
<h3 id="最后">最后</h3>
<p>目前所有的子站</p>
<p><a href="https://img.ikozn.com">图床</a></p>
<p><a href="https://cloud.ikozn.com">Cloud</a></p>
<p><s><a href="https://l4d2.ikozn.com">L4D2摸鱼服</a></s></p>
<p><s><a href="https://minecraft.ikozn.com">Minecraft摸鱼服</a></s></p>
<p><s><a href="https://BBS.ikozn.com">论坛</a></s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[科普]IP地址、子网划分到底是个啥？]]></title>
        <id>https://blog.ikozn.com/post/科普-IP地址、子网划分到底是个啥？/</id>
        <link href="https://blog.ikozn.com/post/科普-IP地址、子网划分到底是个啥？/">
        </link>
        <updated>2017-12-15T10:02:04.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="什么是ip">什么是IP</h3>
<p>IP地址就是<code>网络设备</code>在网络中通信所使用的地址，将通信的数据包比作快递包裹，那么IP地址就相当于你在快递包上填的发货与收货地址。</p>
<p>两条设备需要互相知道对方的地址，才能进行通信。</p>
<p>一般IP地址写作<code>192.168.10.1</code>这样的形式</p>
<p>一个IP地址由三个点分成四个小块，每个小块里都有一个十进制数来表示地址.</p>
<p>所以这种表达IP地址的方式叫做点分十进制,也是我们使用最多的方式.</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="什么是ip">什么是IP</h3>
<p>IP地址就是<code>网络设备</code>在网络中通信所使用的地址，将通信的数据包比作快递包裹，那么IP地址就相当于你在快递包上填的发货与收货地址。</p>
<p>两条设备需要互相知道对方的地址，才能进行通信。</p>
<p>一般IP地址写作<code>192.168.10.1</code>这样的形式</p>
<p>一个IP地址由三个点分成四个小块，每个小块里都有一个十进制数来表示地址.</p>
<p>所以这种表达IP地址的方式叫做点分十进制,也是我们使用最多的方式.</p>
<!--more-->
<blockquote>
<p>Q：那有点分十进制这种表示方法，那是不是还有别的？</p>
<p>A：是的呀，你真鸡儿聪明，往下看。</p>
</blockquote>
<h4 id="二进制的ip">二进制的IP</h4>
<p>IP地址原本的面目是下面这个样子的</p>
<p><code>11000000101010000000101000000001</code></p>
<p>这就是IP地址的二进制表示方法，又臭又长。</p>
<blockquote>
<p>Q：什么鬼呀？！二进制是啥玩意啊？！</p>
<p>A：你丫自己百度去！！</p>
<p>Q：这一串长长的都特喵的是啥玩意？!!</p>
<p>A：这就是把IP地址的点分十进制表示法进制转换成二进制之后的样子啊~</p>
<p>Q：妈耶！这么长记个鬼噢</p>
<p>A：就是因为长，所以才需要点分十进制表示法嘛.</p>
</blockquote>
<p>IP地址的类别再这里不做介绍，有兴趣了解的自行百度</p>
<hr>
<h3 id="ip的表示方法">IP的表示方法</h3>
<h4 id="字节">字节</h4>
<p>首先引入一个概念<code>字节</code></p>
<p>计算机中数据储存最小的单位是<code>位</code>(Bit)，每一个二进制位占一个位。每8位为一<code>字节</code>(Byte)</p>
<p>比如<code>11000</code>这就有5位二进制，就占了5个Bit。</p>
<p>我们再回来看IP地址</p>
<p><code>11000000101010000000101000000001</code></p>
<p>一个IP地址最长为32位二进制,这个地址刚好占了32位。</p>
<p>那么占了多少个字节呢？</p>
<p>来一波简单的计算，<code>32÷8=4</code> 哇哦，四个字节哎.</p>
<blockquote>
<p>Q：点分十进制好像也是把IP分成4个小块哎！莫非...它们之间有什么不可告人的？..</p>
<p>A：妈耶！是有关系冇错，但是不可告人是什么鬼哦？！</p>
</blockquote>
<h4 id="ip地址二-十进制之间的转换">IP地址二、十进制之间的转换</h4>
<p>因为二进制的IP地址贼鸡儿长，所以出现了点分十进制的表示法，方便使用与记忆</p>
<p>我们把一个完整的IP地址使用<code>.</code>分为4个小块，每个小块一个字节。</p>
<p>然后贼鸡儿长的</p>
<p><code>11000000101010000000101000000001</code></p>
<p>就变成了</p>
<p><code>11000000</code>.<code>10101000</code>.<code>00001010</code>.<code>00000001</code></p>
<p>这表示法就叫做点分二进制.由点分隔开来，每个小块里的数都为二进制</p>
<blockquote>
<p>再引入几个概念,<code>第一字节</code> <code>第二字节</code> <code>第三字节</code> <code>第四字节</code></p>
<blockquote>
<p>注意，这个概念是我自己瞎鸡儿搞出来的，方便记忆</p>
</blockquote>
<table>
<thead>
<tr>
<th>11000000</th>
<th>10101000</th>
<th>00001010</th>
<th>00000001</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一字节</td>
<td>第二字节</td>
<td>第三字节</td>
<td>第四字节</td>
</tr>
</tbody>
</table>
<p>如上表所示，因为每个小块为8位二进制，而8位二进制正好为1字节。</p>
<p>所以我第一个小块叫做第一字节，第二个小块叫做第二个字节，以此类推。</p>
</blockquote>
<p>我们把每个字节都转成10进制</p>
<p><strong>第一字节转换成十进制</strong>	<code>192</code></p>
<p><strong>第二字节转换成十进制</strong>	<code>168</code></p>
<p><strong>第三字节转换成十进制</strong>	<code>10</code></p>
<p><strong>第四字节转换成十进制</strong>	<code>1</code></p>
<p>最后再合起来就得到了<code>192.168.10.1</code></p>
<p>想要把点分十进制表示的IP转成十进制只需要反着来就好了</p>
<hr>
<h3 id="一个字节能表达的最大值">一个字节能表达的最大值</h3>
<p>IP地址在十进制的形态下，每字节的值最大只能为255.</p>
<p>IP地址究其本质，还是从二进制转换而来的.</p>
<p>由于每个字节也就只有8位二进制</p>
<p>最小为<code>00000000</code>,最大为<code>11111111</code></p>
<p><code>00000000</code>转换成十进制是0</p>
<p><code>11111111</code>转换成十进制是255</p>
<p>所以每个字节(8位二进制)所能表达值的范围就是 <code>00000000</code>-<code>11111111</code>，转换成十进制也就是 <code>0</code>-<code>255</code></p>
<hr>
<h3 id="掩码与子网">掩码与子网</h3>
<p>通常配置IP地址的时候，还需要配置一个子网掩码。</p>
<p>IP与子网掩码是成对出现的,掩码的作用就是用于判断一个IP地址，是属于哪个子网的。</p>
<h4 id="子网">子网</h4>
<p>之前谈IP地址的时候我们讲过，IP地址相当于你在快递包上填的发货与收货地址。</p>
<p>那么地址一般写的都是<code>A省B市C区D路E小区F单元G号房间</code> 吧，总不能在地址上直接写G房间呀。</p>
<p>所以呢，为了方便管理，一个国家分为了各个省，接着各个省下又分为了各个市</p>
<p>以此类推，就出现了区、路(街)、小区、单元、房间号的概念，都是将一个大的<strong>区域</strong>划分为一个相对小的<strong>区域</strong>。</p>
<p>同样的，IP网络也可以划分成更小的网络，这些更小的网络，我们就称之为<strong>子网</strong></p>
<blockquote>
<p>PS:收货地址并不一定都是这么写，比如我就不一定会精细的写到某某房间</p>
<p>这里只是一个方便理解的比喻，不要钻牛角尖</p>
</blockquote>
<h4 id="掩码">掩码</h4>
<p>因为出现了子网的概念，所以子网掩码就应运而生了。</p>
<p>子网掩码的作用,就是用于判断一个IP地址，是属于哪个子网的。</p>
<h5 id="掩码的表示">掩码的表示</h5>
<p>相信大家最常见的掩码就是 <code>255.255.255.0</code>了吧</p>
<p>掩码转成十进制时候，其实也是点分十进制的表示方式.</p>
<p>转换成二进制就是</p>
<p><code>11111111.11111111.11111111.00000000</code></p>
<p>发现了吗，从左到右全都是<code>1</code></p>
<p>掩码是从左至右由<strong>连续的</strong><code>1</code>组成，不能断开</p>
<p>例如</p>
<p><code>11111111.11110111.11111111.00000000</code></p>
<p>就不是一个掩码</p>
<p>还有一种表示方法为 <code>IP地址</code>/<code>掩码长度</code></p>
<p>比如 <code>192.168.10.1</code>/<code>24</code></p>
<p>就表示 IP地址为 <code>192.168.10.1</code> 而掩码为 <code>11111111.11111111.11111111.00000000</code>（24个1）</p>
<p>也就是<code>255.255.255.0</code></p>
<h5 id="网络位-主机位">网络位 主机位</h5>
<p>简单的说，网络位就是掩码中<code>1</code>的部分，而主机位就是掩码中<code>0</code>的部分</p>
<p>当想知道一个地址的所属哪个子网，也就是获取一个地址的网络号时。</p>
<p>我们使用掩码跟IP地址进行<code>与</code>运算</p>
<p>而想知道主机号的时候，就将掩码取后再跟IP地址进行<code>与</code>运算</p>
<blockquote>
<p><code>与</code>运算是逻辑运算</p>
<p><code>1</code>与任何数相<code>与</code>得到任何数</p>
<p><code>0</code>与任何数相<code>与</code>都得<code>0</code></p>
</blockquote>
<p><strong>举个例子</strong></p>
<p>假设现在有一个IP地址为 <code>192.168.10.1/24</code></p>
<p>为了方便讲解，我们先列一个表</p>
<table>
<thead>
<tr>
<th style="text-align:center">掩码</th>
<th style="text-align:left">11111111</th>
<th style="text-align:left">11111111</th>
<th style="text-align:left">11111111</th>
<th style="text-align:right">00000000</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IP地址二进制</td>
<td style="text-align:left">11000000</td>
<td style="text-align:left">10101000</td>
<td style="text-align:left">00001010</td>
<td style="text-align:right">00000001</td>
</tr>
<tr>
<td style="text-align:center">IP地址十进制</td>
<td style="text-align:left">192</td>
<td style="text-align:left">168</td>
<td style="text-align:left">10</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td style="text-align:center">字节</td>
<td style="text-align:left">第一字节</td>
<td style="text-align:left">第二字节</td>
<td style="text-align:left">第三字节</td>
<td style="text-align:right">第四字节</td>
</tr>
</tbody>
</table>
<p>其中，掩码第一到三字节都为网络位，第四字节为主机位</p>
<h6 id="获取网络号">获取网络号</h6>
<p>按照上面说的.将掩码与IP地址相<code>与</code>，就得到了二进制的网络号</p>
<table>
<thead>
<tr>
<th>掩码</th>
<th style="text-align:center">11111111</th>
<th style="text-align:center">11111111</th>
<th style="text-align:center">11111111</th>
<th style="text-align:center">00000000</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP地址</td>
<td style="text-align:center">11000000</td>
<td style="text-align:center">10101000</td>
<td style="text-align:center">00001010</td>
<td style="text-align:center">00000001</td>
</tr>
<tr>
<td>网络号</td>
<td style="text-align:center">11000000</td>
<td style="text-align:center">10101000</td>
<td style="text-align:center">00001010</td>
<td style="text-align:center">00000000</td>
</tr>
</tbody>
</table>
<p>接着再将相与后的二进制转换成点分十进制，接着我们就得到网络号:<code>192.168.10.0/24</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">11000000</th>
<th style="text-align:center">10101000</th>
<th style="text-align:center">00001010</th>
<th style="text-align:center">00000000</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">192</td>
<td style="text-align:center">168</td>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<h6 id="例获取主机号">例获取主机号</h6>
<p>首先，将掩码取反，也就是将<code>1</code>和<code>0</code>反过来，得到反掩码</p>
<table>
<thead>
<tr>
<th style="text-align:center">原掩码</th>
<th style="text-align:center">11111111</th>
<th style="text-align:center">11111111</th>
<th style="text-align:center">11111111</th>
<th>00000000</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">反掩码</td>
<td style="text-align:center">00000000</td>
<td style="text-align:center">00000000</td>
<td style="text-align:center">00000000</td>
<td>11111111</td>
</tr>
</tbody>
</table>
<p>接着再用反掩码跟IP地址相<code>与</code>，得到主机号的二进制</p>
<table>
<thead>
<tr>
<th>反掩码</th>
<th>00000000</th>
<th>00000000</th>
<th>00000000</th>
<th>11111111</th>
</tr>
</thead>
<tbody>
<tr>
<td>IP地址</td>
<td>11000000</td>
<td>10101000</td>
<td>00001010</td>
<td>00000001</td>
</tr>
<tr>
<td>主机号</td>
<td>00000000</td>
<td>00000000</td>
<td>00000000</td>
<td>00000001</td>
</tr>
</tbody>
</table>
<p>再将结果转成10进制，于是我们就可以得到主机号 :<code>1</code></p>
<h5 id="特殊的地址">特殊的地址</h5>
<p>在子网中，有三钟地址</p>
<p>分别是 <strong>网络号</strong>、<strong>广播地址</strong>、<strong>主机地址</strong></p>
<h6 id="网络号">网络号</h6>
<p>顾名思义，看到名字就明白了，它的作用就是表示一个子网、网段的一个地址.</p>
<p>定义:主机位全<code>0</code>的地址</p>
<p>例如:<code>192.168.10.0/24</code></p>
<h6 id="广播地址">广播地址</h6>
<p>这个刚入门也许有些难以理解</p>
<p>其实这就是<strong>主机</strong>同时向<strong>同个子网</strong>中的<strong>其他所有</strong>主机发送信息时使用的地址</p>
<p>定义:主机全<code>1</code>的地址</p>
<p>例如:<code>192.168.10.255/24</code></p>
<h6 id="主机地址">主机地址</h6>
<p>这个也很好理解，用于表示子网中一台主机的地址</p>
<p>定义:主机位既不是全<code>0</code>,也不是全<code>1</code>的地址</p>
<blockquote>
<p>如果将IP地址比喻做酒店房间地址的话</p>
<p>网络号相当于楼层号，表示一个<strong>楼层</strong></p>
<p>主机地址表示这层楼中的<strong>一间房间</strong></p>
<p>而广播地址，则表示这个楼层中的<strong>所有房间</strong></p>
<p><strong>楼层</strong>包含这层楼的<strong>所有房间</strong></p>
<p><strong>所有房间</strong>包含<strong>一间房间</strong></p>
</blockquote>
<hr>
<h3 id="子网划分">子网划分</h3>
<p><code>待填坑</code></p>
<h4 id="子网划分原理">子网划分原理</h4>
<h6 id="根据主机数划分子网">根据主机数划分子网</h6>
<p><code>待填坑</code></p>
<h6 id="根据子网数划分子网">根据子网数划分子网</h6>
<p><code>待填坑</code></p>
<h4 id="快速子网划分">快速子网划分</h4>
<h6 id="快速划分子网原理">快速划分子网原理</h6>
<p><code>待填坑</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Note]论如何食用KMS激活]]></title>
        <id>https://blog.ikozn.com/post/笔记-论如何食用KMS激活/</id>
        <link href="https://blog.ikozn.com/post/笔记-论如何食用KMS激活/">
        </link>
        <updated>2017-12-15T09:56:40.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="kms-服务器地址">KMS 服务器地址</h3>
<p>推荐使用<a href="https://03k.org/">零散坑</a>的KMS激活服务</p>
<pre><code>kms.03k.org
</code></pre>
<h3 id="kms-version">Kms version</h3>
<pre><code>vlmcsd-1108-2017-01-19-Hotbird64
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h3 id="kms-服务器地址">KMS 服务器地址</h3>
<p>推荐使用<a href="https://03k.org/">零散坑</a>的KMS激活服务</p>
<pre><code>kms.03k.org
</code></pre>
<h3 id="kms-version">Kms version</h3>
<pre><code>vlmcsd-1108-2017-01-19-Hotbird64
</code></pre>
<!--more-->
<h3 id="正片">正片</h3>
<p>一般来说，只要确保的下载的是 VL 批量版本并且没有手动安装过任何 key， 你只需要使用管理员权限运行 cmd 执行一句命令就足够：</p>
<pre><code>slmgr /skms kms.03k.org
</code></pre>
<p>然后去计算机属性或者控制面板其他的什么的地方点一下激活就好了。<br>
当然，如果你懒得点，可以多打一句命令手动激活：</p>
<pre><code>slmgr /ato
</code></pre>
<p>这句命令的意思是，马上对当前设置的 key 和服务器地址等进行尝试激活操作。</p>
<p>kms 激活的前提是你的系统是批量授权版本，即 VL 版，一般企业版都是 VL 版，专业版有零售和 VL 版，家庭版旗舰版 OEM 版等等那就肯定不能用 kms 激活。一般建议从 http://msdn.itellyou.cn 上面下载系统 VL 版本的镜像一般内置 GVLK key，用于 kms 激活。如果你手动输过其他 key，那么这个内置的 key 就会被替换掉，这个时候如果你想用 kms，那么就需要把 GVLK key 输回去。首先， 到 https://technet.microsoft.com/en-us/library/jj612867.aspx 获取你对应版本的 KEY 如果打不开下面有对应的</p>
<p>如果不知道自己的系统是什么版本，可以运行以下命令查看系统版本：</p>
<pre><code>wmic os get caption
</code></pre>
<p>得到对应 key 之后，使用管理员权限运行 cmd 执行安装 key：</p>
<pre><code>slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx
</code></pre>
<p>然后跟上面说的一样设置 kms 服务器地址，激活。</p>
<h3 id="一句命令激活-office">一句命令激活 OFFICE</h3>
<p>首先你的 OFFICE 必须是 VOL 版本，否则无法激活。 找到你的 office 安装目录，比如</p>
<pre><code>C:\Program Files (x86)\Microsoft Office\Office16
</code></pre>
<p>64 位的就是</p>
<pre><code>C:\Program Files\Microsoft Office\Office16
</code></pre>
<p>office16 是 office2016，office15 就是 2013，office14 就是 2010. 然后目录对的话，该目录下面应该有个 OSPP.VBS。 接下来我们就 cd 到这个目录下面，例如：</p>
<pre><code>cd C:\Program Files (x86)\Microsoft Office\Office16
</code></pre>
<p>然后执行注册 kms 服务器地址：</p>
<pre><code>cscript ospp.vbs /sethst:kms.03k.org
</code></pre>
<p>/sethst 参数就是指定 kms 服务器地址。 一般 ospp.vbs 可以拖进去 cmd 窗口，所以也可以这么弄：</p>
<pre><code>cscript &quot;C:\Program Files (x86)\Microsoft Office\Office16\OSPP.VBS&quot; /sethst:kms.03k.org
</code></pre>
<p>一般来说，“一句命令已经完成了”，但一般 office 不会马上连接 kms 服务器进行激活，所以我们额外补充一条手动激活命令：</p>
<pre><code>cscript ospp.vbs /act
</code></pre>
<p>如果提示看到 successful 的字样，那么就是激活成功了，重新打开 office 就好。 如果遇到报错，请检查：</p>
<p>你的系统/OFFICE 是否是批量 VL 版本<br>
是否以管理员权限运行 CMD<br>
你的系统/OFFICE 是否修改过 KEY/未安装 GVLK KEY<br>
检查你的网络连接<br>
服务器繁忙，多试试（点击检查 KMS 服务是否可用）<br>
根据出错代码自己搜索出错原因</p>
<p><a href="https://technet.microsoft.com/en-us/library/jj612867.aspx">Windows GVLK 密钥对照表（KMS 激活专用）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 沉迷剑三 ]]></title>
        <id>https://blog.ikozn.com/post/沉迷剑三/</id>
        <link href="https://blog.ikozn.com/post/沉迷剑三/">
        </link>
        <updated>2017-06-24T09:11:29.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2018/03/31/5abf6bb365875.jpg" alt="JX3" loading="lazy"></figure>
<blockquote>
<p>自在逍遥！</p>
</blockquote>
<!--more-->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[实验记录]单设备双出口NAT]]></title>
        <id>https://blog.ikozn.com/post/实验记录-单设备双出口NAT/</id>
        <link href="https://blog.ikozn.com/post/实验记录-单设备双出口NAT/">
        </link>
        <updated>2017-05-23T03:59:26.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="一-需求">一、需求</h2>
<p>访问联通(20.20.20.0/24)网段的流量走联通<br>
其他流量默认走电信<br>
两条链路互为备份<br>
R3为出口路由器<br>
使用PAT进行NAT</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="一-需求">一、需求</h2>
<p>访问联通(20.20.20.0/24)网段的流量走联通<br>
其他流量默认走电信<br>
两条链路互为备份<br>
R3为出口路由器<br>
使用PAT进行NAT</p>
<!--more-->
<h2 id="二-关键配置">二、关键配置</h2>
<pre><code>R3_config#interface GigaEthernet0/3
R3_config_g0/3# ip nat outside    //设置出口为outside
R3_config_g0/3#!
R3_config#interface GigaEthernet0/4
R3_config_g0/4# ip nat outside    //设置出口为outside
R3_config_g0/4#!
R3_config#interface GigaEthernet0/5
R3_config_g0/5# ip policy route-map PBR    //应用PBR
R3_config_g0/5# ip nat inside    //设置出口为inside
R3_config_g0/5#!
R3_config#ip access-list extended LT    //匹配去往联通的流量
R3_config_ext_nacl# permit ip any 23.23.23.0 255.255.255.0
R3_config_ext_nacl# permit ip any 20.20.20.0 255.255.255.0
R3_config_ext_nacl#!
R3_config#ip access-list extended DX     //匹配出外网的其他的流量
R3_config_ext_nacl# deny   ip any 23.23.23.0 255.255.255.0
R3_config_ext_nacl# deny   ip any 20.20.20.0 255.255.255.0
R3_config_ext_nacl# permit ip any any    
R3_config_ext_nacl#!
R3_config#ip access-list standard USER1    //匹配内网用户
R3_config_std_nacl# permit 3.3.3.0 255.255.255.0
R3_config_std_nacl#!
R3_config#ip access-list standard USER2    //匹配内网用户
R3_config_std_nacl# permit 3.3.3.0 255.255.255.0
R3_config_std_nacl#!
R3_config#route-map PBR 10 permit
R3_config_route_map# match ip address LT
R3_config_route_map# set ip next-hop 23.23.23.2 13.13.13.1 //去往联通的流量默认走联通，电信线路为备份
R3_config_route_map#!
R3_config#route-map PBR 20 permit
R3_config_route_map# match ip address DX
R3_config_route_map# set ip next-hop 13.13.13.1 23.23.23.2     //出外网的其他流量默认走电信，联通线路为
</code></pre>
<p>备份线路实现</p>
<pre><code>R3_config_route_map#!
R3_config#ip nat inside source list ALL1 interface GigaEthernet0/4    //设置NAT
R3_config#ip nat inside source list ALL2 interface GigaEthernet0/3    //设置NAT
R3_config#
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ NAYO图库部署完成]]></title>
        <id>https://blog.ikozn.com/post/NAYO图库部署完成/</id>
        <link href="https://blog.ikozn.com/post/NAYO图库部署完成/">
        </link>
        <updated>2017-02-05T11:57:20.000Z</updated>
        <summary type="html"><![CDATA[<p>~~戳<a href="https://img.nayo.moe">这里</a>访问(๑•̀.̫•́๑)~~Nayo已死，现迁移至新<a href="https://img.ikozn.com">地址</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>~~戳<a href="https://img.nayo.moe">这里</a>访问(๑•̀.̫•́๑)~~Nayo已死，现迁移至新<a href="https://img.ikozn.com">地址</a></p>
<!--more-->
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2018/03/31/5abf7361d0016.jpg" alt="Miv4t" loading="lazy"></figure>
]]></content>
    </entry>
</feed>